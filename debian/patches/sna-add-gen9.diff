commit 4e172a38e1707465c189c56bdb7ee4bdaf54c9d4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Apr 6 15:38:19 2016 +0100

    sna/gen9: Quick and dirty implementation
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/src/sna/Makefile.am b/src/sna/Makefile.am
index e09a8d4..adf1396 100644
--- a/src/sna/Makefile.am
+++ b/src/sna/Makefile.am
@@ -107,6 +107,8 @@ libsna_la_SOURCES = \
 	gen8_render.h \
 	gen8_vertex.c \
 	gen8_vertex.h \
+	gen9_render.c \
+	gen9_render.h \
 	xassert.h \
 	$(NULL)
 
diff --git a/src/sna/gen9_render.c b/src/sna/gen9_render.c
new file mode 100644
index 0000000..2a0c3d3
--- /dev/null
+++ b/src/sna/gen9_render.c
@@ -0,0 +1,4099 @@
+/*
+ * Copyright Â© 2012,2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *    Chris Wilson <chris@chris-wilson.co.uk>
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "sna.h"
+#include "sna_reg.h"
+#include "sna_render.h"
+#include "sna_render_inline.h"
+#include "sna_video.h"
+
+#include "gen9_render.h"
+#include "gen8_eu.h"
+#include "gen4_common.h"
+#include "gen4_source.h"
+#include "gen4_vertex.h"
+#include "gen6_common.h"
+#include "gen8_vertex.h"
+
+#define SIM 1
+
+#define ALWAYS_INVALIDATE 0
+#define ALWAYS_FLUSH 0
+#define ALWAYS_STALL 0
+
+#define NO_COMPOSITE 0
+#define NO_COMPOSITE_SPANS 0
+#define NO_COPY 0
+#define NO_COPY_BOXES 0
+#define NO_FILL 0
+#define NO_FILL_BOXES 0
+#define NO_FILL_ONE 0
+#define NO_FILL_CLEAR 0
+#define NO_VIDEO 0
+
+#define USE_8_PIXEL_DISPATCH 1
+#define USE_16_PIXEL_DISPATCH 1
+#define USE_32_PIXEL_DISPATCH 0
+
+#if !USE_8_PIXEL_DISPATCH && !USE_16_PIXEL_DISPATCH && !USE_32_PIXEL_DISPATCH
+#error "Must select at least 8, 16 or 32 pixel dispatch"
+#endif
+
+#define GEN9_MAX_SIZE 16384
+
+/* XXX Todo
+ *
+ * STR (software tiled rendering) mode. No, really.
+ * 64x32 pixel blocks align with the rendering cache. Worth considering.
+ */
+
+#define is_aligned(x, y) (((x) & ((y) - 1)) == 0)
+
+/* Pipeline stages:
+ *  1. Command Streamer (CS)
+ *  2. Vertex Fetch (VF)
+ *  3. Vertex Shader (VS)
+ *  4. Hull Shader (HS)
+ *  5. Tesselation Engine (TE)
+ *  6. Domain Shader (DS)
+ *  7. Geometry Shader (GS)
+ *  8. Stream Output Logic (SOL)
+ *  9. Clipper (CLIP)
+ * 10. Strip/Fan (SF)
+ * 11. Windower/Masker (WM)
+ * 12. Color Calculator (CC)
+ */
+
+#if !NO_VIDEO
+static const uint32_t ps_kernel_packed[][4] = {
+#include "exa_wm_src_affine.g8b"
+#include "exa_wm_src_sample_argb.g8b"
+#include "exa_wm_yuv_rgb.g8b"
+#include "exa_wm_write.g8b"
+};
+
+static const uint32_t ps_kernel_planar[][4] = {
+#include "exa_wm_src_affine.g8b"
+#include "exa_wm_src_sample_planar.g8b"
+#include "exa_wm_yuv_rgb.g8b"
+#include "exa_wm_write.g8b"
+};
+
+static const uint32_t ps_kernel_rgb[][4] = {
+#include "exa_wm_src_affine.g8b"
+#include "exa_wm_src_sample_argb.g8b"
+#include "exa_wm_write.g8b"
+};
+#endif
+
+#define SURFACE_DW (64 / sizeof(uint32_t));
+
+#define KERNEL(kernel_enum, kernel, num_surfaces) \
+    [GEN9_WM_KERNEL_##kernel_enum] = {#kernel_enum, kernel, sizeof(kernel), num_surfaces}
+#define NOKERNEL(kernel_enum, func, num_surfaces) \
+    [GEN9_WM_KERNEL_##kernel_enum] = {#kernel_enum, (void *)func, 0, num_surfaces}
+static const struct wm_kernel_info {
+	const char *name;
+	const void *data;
+	unsigned int size;
+	int num_surfaces;
+} wm_kernels[] = {
+	NOKERNEL(NOMASK, gen8_wm_kernel__affine, 2),
+	NOKERNEL(NOMASK_P, gen8_wm_kernel__projective, 2),
+
+	NOKERNEL(MASK, gen8_wm_kernel__affine_mask, 3),
+	NOKERNEL(MASK_P, gen8_wm_kernel__projective_mask, 3),
+
+	NOKERNEL(MASKCA, gen8_wm_kernel__affine_mask_ca, 3),
+	NOKERNEL(MASKCA_P, gen8_wm_kernel__projective_mask_ca, 3),
+
+	NOKERNEL(MASKSA, gen8_wm_kernel__affine_mask_sa, 3),
+	NOKERNEL(MASKSA_P, gen8_wm_kernel__projective_mask_sa, 3),
+
+	NOKERNEL(OPACITY, gen8_wm_kernel__affine_opacity, 2),
+	NOKERNEL(OPACITY_P, gen8_wm_kernel__projective_opacity, 2),
+
+#if !NO_VIDEO
+	KERNEL(VIDEO_PLANAR, ps_kernel_planar, 7),
+	KERNEL(VIDEO_PACKED, ps_kernel_packed, 2),
+	KERNEL(VIDEO_RGB, ps_kernel_rgb, 2),
+#endif
+};
+#undef KERNEL
+
+static const struct blendinfo {
+	uint8_t src_alpha;
+	uint8_t src_blend;
+	uint8_t dst_blend;
+} gen9_blend_op[] = {
+	/* Clear */	{0, BLENDFACTOR_ZERO, BLENDFACTOR_ZERO},
+	/* Src */	{0, BLENDFACTOR_ONE, BLENDFACTOR_ZERO},
+	/* Dst */	{0, BLENDFACTOR_ZERO, BLENDFACTOR_ONE},
+	/* Over */	{1, BLENDFACTOR_ONE, BLENDFACTOR_INV_SRC_ALPHA},
+	/* OverReverse */ {0, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_ONE},
+	/* In */	{0, BLENDFACTOR_DST_ALPHA, BLENDFACTOR_ZERO},
+	/* InReverse */	{1, BLENDFACTOR_ZERO, BLENDFACTOR_SRC_ALPHA},
+	/* Out */	{0, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_ZERO},
+	/* OutReverse */ {1, BLENDFACTOR_ZERO, BLENDFACTOR_INV_SRC_ALPHA},
+	/* Atop */	{1, BLENDFACTOR_DST_ALPHA, BLENDFACTOR_INV_SRC_ALPHA},
+	/* AtopReverse */ {1, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_SRC_ALPHA},
+	/* Xor */	{1, BLENDFACTOR_INV_DST_ALPHA, BLENDFACTOR_INV_SRC_ALPHA},
+	/* Add */	{0, BLENDFACTOR_ONE, BLENDFACTOR_ONE},
+};
+
+/**
+ * Highest-valued BLENDFACTOR used in gen9_blend_op.
+ *
+ * This leaves out GEN9_BLENDFACTOR_INV_DST_COLOR,
+ * GEN9_BLENDFACTOR_INV_CONST_{COLOR,ALPHA},
+ * GEN9_BLENDFACTOR_INV_SRC1_{COLOR,ALPHA}
+ */
+#define GEN9_BLENDFACTOR_COUNT (BLENDFACTOR_INV_DST_ALPHA + 1)
+
+#define GEN9_BLEND_STATE_PADDED_SIZE	ALIGN(sizeof(struct gen9_blend_state), 64)
+
+#define BLEND_OFFSET(s, d) \
+	((d != BLENDFACTOR_ZERO) << 15 | ((s) * GEN9_BLENDFACTOR_COUNT + (d)) << 4)
+
+#define NO_BLEND BLEND_OFFSET(BLENDFACTOR_ONE, BLENDFACTOR_ZERO)
+#define CLEAR BLEND_OFFSET(BLENDFACTOR_ZERO, BLENDFACTOR_ZERO)
+
+#define SAMPLER_OFFSET(sf, se, mf, me) \
+	(((((sf) * EXTEND_COUNT + (se)) * FILTER_COUNT + (mf)) * EXTEND_COUNT + (me)) + 2)
+
+#define VERTEX_2s2s 0
+
+#define COPY_SAMPLER 0
+#define COPY_VERTEX VERTEX_2s2s
+#define COPY_FLAGS(a) GEN9_SET_FLAGS(COPY_SAMPLER, (a) == GXcopy ? NO_BLEND : CLEAR, GEN9_WM_KERNEL_NOMASK, COPY_VERTEX)
+
+#define FILL_SAMPLER 1
+#define FILL_VERTEX VERTEX_2s2s
+#define FILL_FLAGS(op, format) GEN9_SET_FLAGS(FILL_SAMPLER, gen9_get_blend((op), false, (format)), GEN9_WM_KERNEL_NOMASK, FILL_VERTEX)
+#define FILL_FLAGS_NOBLEND GEN9_SET_FLAGS(FILL_SAMPLER, NO_BLEND, GEN9_WM_KERNEL_NOMASK, FILL_VERTEX)
+
+#define GEN9_SAMPLER(f) (((f) >> 20) & 0xfff)
+#define GEN9_BLEND(f) (((f) >> 4) & 0x7ff)
+#define GEN9_READS_DST(f) (((f) >> 15) & 1)
+#define GEN9_KERNEL(f) (((f) >> 16) & 0xf)
+#define GEN9_VERTEX(f) (((f) >> 0) & 0xf)
+#define GEN9_SET_FLAGS(S, B, K, V)  ((S) << 20 | (K) << 16 | (B) | (V))
+
+#define OUT_BATCH(v) batch_emit(sna, v)
+#define OUT_BATCH64(v) batch_emit64(sna, v)
+#define OUT_VERTEX(x,y) vertex_emit_2s(sna, x,y)
+#define OUT_VERTEX_F(v) vertex_emit(sna, v)
+
+struct gt_info {
+	const char *name;
+	struct {
+		int max_vs_entries;
+	} urb;
+};
+
+static const struct gt_info min_gt_info = {
+	.name = "Skylake (gen9)",
+	.urb = { .max_vs_entries = 240 },
+};
+
+static const struct gt_info skl_gt_info = {
+	.name = "Skylake (gen9)",
+	.urb = { .max_vs_entries = 960 },
+};
+
+static bool is_skl(struct sna *sna)
+{
+	return sna->kgem.gen == 0110;
+}
+
+static inline bool too_large(int width, int height)
+{
+	return width > GEN9_MAX_SIZE || height > GEN9_MAX_SIZE;
+}
+
+static inline bool unaligned(struct kgem_bo *bo, int bpp)
+{
+	/* XXX What exactly do we need to meet H_ALIGN and V_ALIGN? */
+#if 0
+	int x, y;
+
+	if (bo->proxy == NULL)
+		return false;
+
+	/* Assume that all tiled proxies are constructed correctly. */
+	if (bo->tiling)
+		return false;
+
+	DBG(("%s: checking alignment of a linear proxy, offset=%d, pitch=%d, bpp=%d: => (%d, %d)\n",
+	     __FUNCTION__, bo->delta, bo->pitch, bpp,
+	     8 * (bo->delta % bo->pitch) / bpp, bo->delta / bo->pitch));
+
+	/* This may be a random userptr map, check that it meets the
+	 * render alignment of SURFACE_VALIGN_4 | SURFACE_HALIGN_4.
+	 */
+	y = bo->delta / bo->pitch;
+	if (y & 3)
+		return true;
+
+	x = 8 * (bo->delta - y * bo->pitch);
+	if (x & (4*bpp - 1))
+	    return true;
+
+	return false;
+#else
+	return false;
+#endif
+}
+
+static uint32_t gen9_get_blend(int op,
+			       bool has_component_alpha,
+			       uint32_t dst_format)
+{
+	uint32_t src, dst;
+
+	COMPILE_TIME_ASSERT(BLENDFACTOR_INV_DST_ALPHA*GEN9_BLENDFACTOR_COUNT + BLENDFACTOR_INV_DST_ALPHA <= 0x7ff);
+
+	src = gen9_blend_op[op].src_blend;
+	dst = gen9_blend_op[op].dst_blend;
+
+	/* If there's no dst alpha channel, adjust the blend op so that
+	 * we'll treat it always as 1.
+	 */
+	if (PICT_FORMAT_A(dst_format) == 0) {
+		if (src == BLENDFACTOR_DST_ALPHA)
+			src = BLENDFACTOR_ONE;
+		else if (src == BLENDFACTOR_INV_DST_ALPHA)
+			src = BLENDFACTOR_ZERO;
+	}
+
+	/* If the source alpha is being used, then we should only be in a
+	 * case where the source blend factor is 0, and the source blend
+	 * value is the mask channels multiplied by the source picture's alpha.
+	 */
+	if (has_component_alpha && gen9_blend_op[op].src_alpha) {
+		if (dst == BLENDFACTOR_SRC_ALPHA)
+			dst = BLENDFACTOR_SRC_COLOR;
+		else if (dst == BLENDFACTOR_INV_SRC_ALPHA)
+			dst = BLENDFACTOR_INV_SRC_COLOR;
+	}
+
+	DBG(("blend op=%d, dst=%x [A=%d] => src=%d, dst=%d => offset=%x\n",
+	     op, dst_format, PICT_FORMAT_A(dst_format),
+	     src, dst, (int)(BLEND_OFFSET(src, dst)>>4)));
+	assert(BLEND_OFFSET(src, dst) >> 4 <= 0xfff);
+	return BLEND_OFFSET(src, dst);
+}
+
+static uint32_t gen9_get_card_format(PictFormat format)
+{
+	switch (format) {
+	default:
+		return -1;
+	case PICT_a8r8g8b8:
+		return SURFACEFORMAT_B8G8R8A8_UNORM;
+	case PICT_x8r8g8b8:
+		return SURFACEFORMAT_B8G8R8X8_UNORM;
+	case PICT_a8b8g8r8:
+		return SURFACEFORMAT_R8G8B8A8_UNORM;
+	case PICT_x8b8g8r8:
+		return SURFACEFORMAT_R8G8B8X8_UNORM;
+#ifdef PICT_a2r10g10b10
+	case PICT_a2r10g10b10:
+		return SURFACEFORMAT_B10G10R10A2_UNORM;
+	case PICT_x2r10g10b10:
+		return SURFACEFORMAT_B10G10R10X2_UNORM;
+#endif
+	case PICT_r8g8b8:
+		return SURFACEFORMAT_R8G8B8_UNORM;
+	case PICT_r5g6b5:
+		return SURFACEFORMAT_B5G6R5_UNORM;
+	case PICT_a1r5g5b5:
+		return SURFACEFORMAT_B5G5R5A1_UNORM;
+	case PICT_a8:
+		return SURFACEFORMAT_A8_UNORM;
+	case PICT_a4r4g4b4:
+		return SURFACEFORMAT_B4G4R4A4_UNORM;
+	}
+}
+
+static uint32_t gen9_get_dest_format(PictFormat format)
+{
+	switch (format) {
+	default:
+		return -1;
+	case PICT_a8r8g8b8:
+	case PICT_x8r8g8b8:
+		return SURFACEFORMAT_B8G8R8A8_UNORM;
+	case PICT_a8b8g8r8:
+	case PICT_x8b8g8r8:
+		return SURFACEFORMAT_R8G8B8A8_UNORM;
+#ifdef PICT_a2r10g10b10
+	case PICT_a2r10g10b10:
+	case PICT_x2r10g10b10:
+		return SURFACEFORMAT_B10G10R10A2_UNORM;
+#endif
+	case PICT_r5g6b5:
+		return SURFACEFORMAT_B5G6R5_UNORM;
+	case PICT_x1r5g5b5:
+	case PICT_a1r5g5b5:
+		return SURFACEFORMAT_B5G5R5A1_UNORM;
+	case PICT_a8:
+		return SURFACEFORMAT_A8_UNORM;
+	case PICT_a4r4g4b4:
+	case PICT_x4r4g4b4:
+		return SURFACEFORMAT_B4G4R4A4_UNORM;
+	}
+}
+
+static bool gen9_check_dst_format(PictFormat format)
+{
+	if (gen9_get_dest_format(format) != -1)
+		return true;
+
+	DBG(("%s: unhandled format: %x\n", __FUNCTION__, (int)format));
+	return false;
+}
+
+static bool gen9_check_format(uint32_t format)
+{
+	if (gen9_get_card_format(format) != -1)
+		return true;
+
+	DBG(("%s: unhandled format: %x\n", __FUNCTION__, (int)format));
+	return false;
+}
+
+static uint32_t gen9_filter(uint32_t filter)
+{
+	switch (filter) {
+	default:
+		assert(0);
+	case PictFilterNearest:
+		return SAMPLER_FILTER_NEAREST;
+	case PictFilterBilinear:
+		return SAMPLER_FILTER_BILINEAR;
+	}
+}
+
+static uint32_t gen9_check_filter(PicturePtr picture)
+{
+	switch (picture->filter) {
+	case PictFilterNearest:
+	case PictFilterBilinear:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static uint32_t gen9_repeat(uint32_t repeat)
+{
+	switch (repeat) {
+	default:
+		assert(0);
+	case RepeatNone:
+		return SAMPLER_EXTEND_NONE;
+	case RepeatNormal:
+		return SAMPLER_EXTEND_REPEAT;
+	case RepeatPad:
+		return SAMPLER_EXTEND_PAD;
+	case RepeatReflect:
+		return SAMPLER_EXTEND_REFLECT;
+	}
+}
+
+static bool gen9_check_repeat(PicturePtr picture)
+{
+	if (!picture->repeat)
+		return true;
+
+	switch (picture->repeatType) {
+	case RepeatNone:
+	case RepeatNormal:
+	case RepeatPad:
+	case RepeatReflect:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int
+gen9_choose_composite_kernel(int op, bool has_mask, bool is_ca, bool is_affine)
+{
+	int base;
+
+	if (has_mask) {
+		if (is_ca) {
+			if (gen9_blend_op[op].src_alpha)
+				base = GEN9_WM_KERNEL_MASKSA;
+			else
+				base = GEN9_WM_KERNEL_MASKCA;
+		} else
+			base = GEN9_WM_KERNEL_MASK;
+	} else
+		base = GEN9_WM_KERNEL_NOMASK;
+
+	return base + !is_affine;
+}
+
+static void
+gen9_emit_push_constants(struct sna *sna)
+{
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_VS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_HS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_DS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_GS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_PS | (2 - 2));
+	OUT_BATCH(0);
+#endif
+}
+
+static void
+gen9_emit_urb(struct sna *sna)
+{
+	/* num of VS entries must be divisible by 8 if size < 9 */
+	OUT_BATCH(GEN9_3DSTATE_URB_VS | (2 - 2));
+	OUT_BATCH(sna->render_state.gen9.info->urb.max_vs_entries << URB_ENTRY_NUMBER_SHIFT |
+		  (2 - 1) << URB_ENTRY_SIZE_SHIFT |
+		  4 << URB_STARTING_ADDRESS_SHIFT);
+
+	OUT_BATCH(GEN9_3DSTATE_URB_HS | (2 - 2));
+	OUT_BATCH(0 << URB_ENTRY_SIZE_SHIFT |
+		  4 << URB_STARTING_ADDRESS_SHIFT);
+
+	OUT_BATCH(GEN9_3DSTATE_URB_DS | (2 - 2));
+	OUT_BATCH(0 << URB_ENTRY_SIZE_SHIFT |
+		  4 << URB_STARTING_ADDRESS_SHIFT);
+
+	OUT_BATCH(GEN9_3DSTATE_URB_GS | (2 - 2));
+	OUT_BATCH(0 << URB_ENTRY_SIZE_SHIFT |
+		  4 << URB_STARTING_ADDRESS_SHIFT);
+}
+
+static void
+gen9_emit_state_base_address(struct sna *sna)
+{
+	uint32_t num_pages;
+
+	assert(sna->kgem.surface - sna->kgem.nbatch <= 16384);
+
+	/* WaBindlessSurfaceStateModifyEnable:skl,bxt */
+	OUT_BATCH(GEN9_STATE_BASE_ADDRESS | (19 - 1 - 2));
+	OUT_BATCH64(0); /* general */
+	OUT_BATCH(0); /* stateless dataport */
+	OUT_BATCH64(kgem_add_reloc64(&sna->kgem, /* surface */
+				     sna->kgem.nbatch,
+				     NULL,
+				     I915_GEM_DOMAIN_INSTRUCTION << 16,
+				     BASE_ADDRESS_MODIFY));
+	OUT_BATCH64(kgem_add_reloc64(&sna->kgem, /* dynamic */
+				     sna->kgem.nbatch,
+				     sna->render_state.gen9.general_bo,
+				     I915_GEM_DOMAIN_INSTRUCTION << 16,
+				     BASE_ADDRESS_MODIFY));
+	OUT_BATCH64(0); /* indirect */
+	OUT_BATCH64(kgem_add_reloc64(&sna->kgem, /* instruction */
+				     sna->kgem.nbatch,
+				     sna->render_state.gen9.general_bo,
+				     I915_GEM_DOMAIN_INSTRUCTION << 16,
+				     BASE_ADDRESS_MODIFY));
+	/* upper bounds */
+	num_pages = sna->render_state.gen9.general_bo->size.pages.count;
+	OUT_BATCH(0); /* general */
+	OUT_BATCH(num_pages << 12 | 1); /* dynamic */
+	OUT_BATCH(0); /* indirect */
+	OUT_BATCH(num_pages << 12 | 1); /* instruction */
+
+	/* Bindless */
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+}
+
+static void
+gen9_emit_vs_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_VS | (9 - 2));
+	OUT_BATCH64(0); /* no VS kernel */
+	OUT_BATCH(0);
+	OUT_BATCH64(0); /* scratch */
+	OUT_BATCH(0);
+	OUT_BATCH(1 << 1); /* pass-through */
+	OUT_BATCH(1 << 16 | 1 << 21); /* urb write to SBE */
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_CONSTANT_VS | (11 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+
+	OUT_BATCH(GEN9_3DSTATE_BINDING_TABLE_POINTERS_VS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_SAMPLER_STATE_POINTERS_VS | (2 - 2));
+	OUT_BATCH(0);
+#endif
+}
+
+static void
+gen9_emit_hs_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_HS | (9 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH64(0); /* no HS kernel */
+	OUT_BATCH64(0); /* scratch */
+	OUT_BATCH(0);
+	OUT_BATCH(0); /* pass-through */
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_CONSTANT_HS | (11 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+
+#if 1
+	OUT_BATCH(GEN9_3DSTATE_BINDING_TABLE_POINTERS_HS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_SAMPLER_STATE_POINTERS_HS | (2 - 2));
+	OUT_BATCH(0);
+#endif
+#endif
+}
+
+static void
+gen9_emit_te_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_TE | (4 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+}
+
+static void
+gen9_emit_ds_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_DS | (11 - 2));
+	OUT_BATCH64(0); /* no kernel */
+	OUT_BATCH(0);
+	OUT_BATCH64(0); /* scratch */
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_CONSTANT_DS | (11 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+
+#if 1
+	OUT_BATCH(GEN9_3DSTATE_BINDING_TABLE_POINTERS_DS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_SAMPLER_STATE_POINTERS_DS | (2 - 2));
+	OUT_BATCH(0);
+#endif
+#endif
+}
+
+static void
+gen9_emit_gs_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_GS | (10 - 2));
+	OUT_BATCH64(0); /* no GS kernel */
+	OUT_BATCH(0);
+	OUT_BATCH64(0); /* scratch */
+	OUT_BATCH(0);
+	OUT_BATCH(0); /* pass-through */
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_CONSTANT_GS | (11 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+
+#if 1
+	OUT_BATCH(GEN9_3DSTATE_BINDING_TABLE_POINTERS_GS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_SAMPLER_STATE_POINTERS_GS | (2 - 2));
+	OUT_BATCH(0);
+#endif
+#endif
+}
+
+static void
+gen9_emit_sol_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_STREAMOUT | (5 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+}
+
+static void
+gen9_emit_sf_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_SF | (4 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+}
+
+static void
+gen9_emit_clip_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_CLIP | (4 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0); /* pass-through */
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_VIEWPORT_STATE_POINTERS_SF_CLIP | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_VIEWPORT_STATE_POINTERS_CC | (2 - 2));
+	OUT_BATCH(0);
+}
+
+static void
+gen9_emit_null_depth_buffer(struct sna *sna)
+{
+	OUT_BATCH(GEN9_3DSTATE_DEPTH_BUFFER | (8 - 2));
+#if 1
+	OUT_BATCH(SURFACE_NULL << DEPTH_BUFFER_TYPE_SHIFT |
+		  DEPTHFORMAT_D32_FLOAT << DEPTH_BUFFER_FORMAT_SHIFT);
+#else
+	OUT_BATCH(SURFACE_2D << DEPTH_BUFFER_TYPE_SHIFT |
+		  DEPTHFORMAT_D16_UNORM << DEPTH_BUFFER_FORMAT_SHIFT);
+#endif
+	OUT_BATCH64(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_HIER_DEPTH_BUFFER | (5 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH64(0);
+	OUT_BATCH(0);
+#endif
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_STENCIL_BUFFER | (5 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH64(0);
+	OUT_BATCH(0);
+#endif
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_WM_DEPTH_STENCIL | (4 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+#endif
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_CLEAR_PARAMS | (3 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+#endif
+}
+
+static void
+gen9_emit_wm_invariant(struct sna *sna)
+{
+	gen9_emit_null_depth_buffer(sna);
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_SCISSOR_STATE_POINTERS | (2 - 2));
+	OUT_BATCH(0);
+#endif
+
+	OUT_BATCH(GEN9_3DSTATE_WM | (2 - 2));
+	//OUT_BATCH(WM_NONPERSPECTIVE_PIXEL_BARYCENTRIC); /* XXX */
+	OUT_BATCH(WM_PERSPECTIVE_PIXEL_BARYCENTRIC);
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_WM_CHROMAKEY | (2 - 2));
+	OUT_BATCH(0);
+#endif
+
+#if 0
+	OUT_BATCH(GEN9_3DSTATE_WM_HZ_OP | (5 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+#endif
+
+	OUT_BATCH(GEN9_3DSTATE_PS_EXTRA | (2 - 2));
+	OUT_BATCH(PSX_PIXEL_SHADER_VALID |
+		  PSX_ATTRIBUTE_ENABLE);
+
+	OUT_BATCH(GEN9_3DSTATE_RASTER | (5 - 2));
+	OUT_BATCH(RASTER_FRONT_WINDING_CCW |
+		  RASTER_CULL_NONE);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_SBE_SWIZ | (11 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_CONSTANT_PS | (11 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+#endif
+}
+
+static void
+gen9_emit_cc_invariant(struct sna *sna)
+{
+}
+
+static void
+gen9_emit_vf_invariant(struct sna *sna)
+{
+	int n;
+
+#if 1
+	OUT_BATCH(GEN9_3DSTATE_VF | (2 - 2));
+	OUT_BATCH(0);
+#endif
+
+	OUT_BATCH(GEN9_3DSTATE_VF_SGVS | (2 - 2));
+	OUT_BATCH(0);
+
+	OUT_BATCH(GEN9_3DSTATE_VF_TOPOLOGY | (2 - 2));
+	OUT_BATCH(RECTLIST);
+
+	OUT_BATCH(GEN9_3DSTATE_VF_STATISTICS | 0);
+
+	for (n = 1; n <= 3; n++) {
+		OUT_BATCH(GEN9_3DSTATE_VF_INSTANCING | (3 - 2));
+		OUT_BATCH(n);
+		OUT_BATCH(0);
+	}
+}
+
+static void
+gen9_emit_invariant(struct sna *sna)
+{
+	OUT_BATCH(GEN9_PIPELINE_SELECT |
+		  PIPELINE_SELECTION_MASK |
+		  PIPELINE_SELECT_3D);
+
+#if SIM
+	OUT_BATCH(GEN9_STATE_SIP | (3 - 2));
+	OUT_BATCH64(0);
+#endif
+
+	OUT_BATCH(GEN9_3DSTATE_MULTISAMPLE | (2 - 2));
+	OUT_BATCH(MULTISAMPLE_PIXEL_LOCATION_CENTER |
+		  MULTISAMPLE_NUMSAMPLES_1); /* 1 sample/pixel */
+
+	OUT_BATCH(GEN9_3DSTATE_SAMPLE_MASK | (2 - 2));
+	OUT_BATCH(1);
+
+#if SIM
+	OUT_BATCH(GEN9_3DSTATE_SAMPLE_PATTERN | (5 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+	//OUT_BATCH(8<<20 | 8<<16);
+	OUT_BATCH(0);
+#endif
+
+	gen9_emit_push_constants(sna);
+	gen9_emit_urb(sna);
+
+	gen9_emit_state_base_address(sna);
+
+	gen9_emit_vf_invariant(sna);
+	gen9_emit_vs_invariant(sna);
+	gen9_emit_hs_invariant(sna);
+	gen9_emit_te_invariant(sna);
+	gen9_emit_ds_invariant(sna);
+	gen9_emit_gs_invariant(sna);
+	gen9_emit_sol_invariant(sna);
+	gen9_emit_clip_invariant(sna);
+	gen9_emit_sf_invariant(sna);
+	gen9_emit_wm_invariant(sna);
+	gen9_emit_cc_invariant(sna);
+
+	sna->render_state.gen9.needs_invariant = false;
+}
+
+static void
+gen9_emit_cc(struct sna *sna, uint32_t blend)
+{
+	struct gen9_render_state *render = &sna->render_state.gen9;
+
+	if (render->blend == blend)
+		return;
+
+	DBG(("%s: blend=%x (current=%x), src=%d, dst=%d\n",
+	     __FUNCTION__, blend, render->blend,
+	     blend / GEN9_BLENDFACTOR_COUNT,
+	     blend % GEN9_BLENDFACTOR_COUNT));
+
+	assert(blend < GEN9_BLENDFACTOR_COUNT * GEN9_BLENDFACTOR_COUNT);
+	assert(blend / GEN9_BLENDFACTOR_COUNT > 0);
+	assert(blend % GEN9_BLENDFACTOR_COUNT > 0);
+
+	/* XXX can have up to 8 blend states preload, selectable via
+	 * Render Target Index. What other side-effects of Render Target Index?
+	 */
+
+	OUT_BATCH(GEN9_3DSTATE_PS_BLEND | (2 - 2));
+	if (blend != GEN9_BLEND(NO_BLEND)) {
+		uint32_t src = blend / GEN9_BLENDFACTOR_COUNT;
+		uint32_t dst = blend % GEN9_BLENDFACTOR_COUNT;
+		OUT_BATCH(PS_BLEND_HAS_WRITEABLE_RT |
+			  PS_BLEND_COLOR_BLEND_ENABLE |
+			  src << PS_BLEND_SRC_ALPHA_SHIFT |
+			  dst << PS_BLEND_DST_ALPHA_SHIFT |
+			  src << PS_BLEND_SRC_SHIFT |
+			  dst << PS_BLEND_DST_SHIFT);
+	} else
+		OUT_BATCH(PS_BLEND_HAS_WRITEABLE_RT);
+
+	assert(is_aligned(render->cc_blend + blend * GEN9_BLEND_STATE_PADDED_SIZE, 64));
+	OUT_BATCH(GEN9_3DSTATE_BLEND_STATE_POINTERS | (2 - 2));
+	OUT_BATCH((render->cc_blend + blend * GEN9_BLEND_STATE_PADDED_SIZE) | 1);
+
+	/* Force a CC_STATE pointer change to improve blend performance */
+	OUT_BATCH(GEN9_3DSTATE_CC_STATE_POINTERS | (2 - 2));
+	OUT_BATCH(0);
+
+	render->blend = blend;
+}
+
+static void
+gen9_emit_sampler(struct sna *sna, uint32_t state)
+{
+	if (sna->render_state.gen9.samplers == state)
+		return;
+
+	sna->render_state.gen9.samplers = state;
+
+	DBG(("%s: sampler = %x\n", __FUNCTION__, state));
+
+	assert(2 * sizeof(struct gen9_sampler_state) == 32);
+	OUT_BATCH(GEN9_3DSTATE_SAMPLER_STATE_POINTERS_PS | (2 - 2));
+	OUT_BATCH(sna->render_state.gen9.wm_state + state * 2 * sizeof(struct gen9_sampler_state));
+}
+
+static void
+gen9_emit_sf(struct sna *sna, bool has_mask)
+{
+	int num_sf_outputs = has_mask ? 2 : 1;
+
+	if (sna->render_state.gen9.num_sf_outputs == num_sf_outputs)
+		return;
+
+	DBG(("%s: num_sf_outputs=%d\n", __FUNCTION__, num_sf_outputs));
+
+	sna->render_state.gen9.num_sf_outputs = num_sf_outputs;
+
+	OUT_BATCH(GEN9_3DSTATE_SBE | (6 - 2));
+	OUT_BATCH(num_sf_outputs << SBE_NUM_OUTPUTS_SHIFT |
+		  SBE_FORCE_VERTEX_URB_READ_LENGTH | /* forced is faster */
+		  SBE_FORCE_VERTEX_URB_READ_OFFSET |
+		  1 << SBE_URB_ENTRY_READ_LENGTH_SHIFT |
+		  1 << SBE_URB_ENTRY_READ_OFFSET_SHIFT);
+	OUT_BATCH(0);
+	OUT_BATCH(0);
+        OUT_BATCH(SBE_ACTIVE_COMPONENT_XYZW << 0 |
+		  SBE_ACTIVE_COMPONENT_XYZW << 1);
+        OUT_BATCH(0);
+}
+
+static void
+gen9_emit_wm(struct sna *sna, int kernel)
+{
+	const uint32_t *kernels;
+
+	assert(kernel < ARRAY_SIZE(wm_kernels));
+	if (sna->render_state.gen9.kernel == kernel)
+		return;
+
+	sna->render_state.gen9.kernel = kernel;
+	kernels = sna->render_state.gen9.wm_kernel[kernel];
+
+	DBG(("%s: switching to %s, num_surfaces=%d (8-wide? %d, 16-wide? %d, 32-wide? %d)\n",
+	     __FUNCTION__,
+	     wm_kernels[kernel].name,
+	     wm_kernels[kernel].num_surfaces,
+	     kernels[0], kernels[1], kernels[2]));
+	assert(is_aligned(kernels[0], 64));
+	assert(is_aligned(kernels[1], 64));
+	assert(is_aligned(kernels[2], 64));
+
+	OUT_BATCH(GEN9_3DSTATE_PS | (12 - 2));
+	OUT_BATCH64(kernels[0] ?: kernels[1] ?: kernels[2]);
+	OUT_BATCH(1 << PS_SAMPLER_COUNT_SHIFT |
+		  PS_VECTOR_MASK_ENABLE |
+		  wm_kernels[kernel].num_surfaces << PS_BINDING_TABLE_ENTRY_COUNT_SHIFT);
+	OUT_BATCH64(0); /* scratch address */
+	OUT_BATCH(PS_MAX_THREADS |
+		  (kernels[0] ? PS_8_DISPATCH_ENABLE : 0) |
+		  (kernels[1] ? PS_16_DISPATCH_ENABLE : 0) |
+		  (kernels[2] ? PS_32_DISPATCH_ENABLE : 0));
+	OUT_BATCH((kernels[0] ? 4 : kernels[1] ? 6 : 8) << PS_DISPATCH_START_GRF_SHIFT_0 |
+		  8 << PS_DISPATCH_START_GRF_SHIFT_1 |
+		  6 << PS_DISPATCH_START_GRF_SHIFT_2);
+	OUT_BATCH64(kernels[2]);
+	OUT_BATCH64(kernels[1]);
+}
+
+static bool
+gen9_emit_binding_table(struct sna *sna, uint16_t offset)
+{
+	if (sna->render_state.gen9.surface_table == offset)
+		return false;
+
+	/* Binding table pointers */
+	assert(is_aligned(4*offset, 32));
+	OUT_BATCH(GEN9_3DSTATE_BINDING_TABLE_POINTERS_PS | (2 - 2));
+	OUT_BATCH(offset*4);
+
+	sna->render_state.gen9.surface_table = offset;
+	return true;
+}
+
+static bool
+gen9_emit_drawing_rectangle(struct sna *sna,
+			    const struct sna_composite_op *op)
+{
+	uint32_t limit = (op->dst.height - 1) << 16 | (op->dst.width - 1);
+	uint32_t offset = (uint16_t)op->dst.y << 16 | (uint16_t)op->dst.x;
+
+	assert(!too_large(abs(op->dst.x), abs(op->dst.y)));
+	assert(!too_large(op->dst.width, op->dst.height));
+
+	if (sna->render_state.gen9.drawrect_limit == limit &&
+	    sna->render_state.gen9.drawrect_offset == offset)
+		return true;
+
+	sna->render_state.gen9.drawrect_offset = offset;
+	sna->render_state.gen9.drawrect_limit = limit;
+
+	OUT_BATCH(GEN9_3DSTATE_DRAWING_RECTANGLE | (4 - 2));
+	OUT_BATCH(0);
+	OUT_BATCH(limit);
+	OUT_BATCH(offset);
+	return false;
+}
+
+static void
+gen9_emit_vertex_elements(struct sna *sna,
+			  const struct sna_composite_op *op)
+{
+	/*
+	 * vertex data in vertex buffer
+	 *    position: (x, y)
+	 *    texture coordinate 0: (u0, v0) if (is_affine is true) else (u0, v0, w0)
+	 *    texture coordinate 1 if (has_mask is true): same as above
+	 */
+	struct gen9_render_state *render = &sna->render_state.gen9;
+	uint32_t src_format, dw;
+	int id = GEN9_VERTEX(op->u.gen9.flags);
+	bool has_mask;
+
+	DBG(("%s: setup id=%d\n", __FUNCTION__, id));
+
+	if (render->ve_id == id)
+		return;
+	render->ve_id = id;
+
+	/* The VUE layout
+	 *    dword 0-3: pad (0.0, 0.0, 0.0. 0.0)
+	 *    dword 4-7: position (x, y, 1.0, 1.0),
+	 *    dword 8-11: texture coordinate 0 (u0, v0, w0, 1.0)
+	 *    dword 12-15: texture coordinate 1 (u1, v1, w1, 1.0)
+	 *
+	 * dword 4-15 are fetched from vertex buffer
+	 */
+	has_mask = (id >> 2) != 0;
+	OUT_BATCH(GEN9_3DSTATE_VERTEX_ELEMENTS |
+		((2 * (3 + has_mask)) + 1 - 2));
+
+	OUT_BATCH(id << VE_INDEX_SHIFT | VE_VALID |
+		  SURFACEFORMAT_R32G32B32A32_FLOAT << VE_FORMAT_SHIFT |
+		  0 << VE_OFFSET_SHIFT);
+	OUT_BATCH(COMPONENT_STORE_0 << VE_COMPONENT_0_SHIFT |
+		  COMPONENT_STORE_0 << VE_COMPONENT_1_SHIFT |
+		  COMPONENT_STORE_0 << VE_COMPONENT_2_SHIFT |
+		  COMPONENT_STORE_0 << VE_COMPONENT_3_SHIFT);
+
+	/* x,y */
+	OUT_BATCH(id << VE_INDEX_SHIFT | VE_VALID |
+		  SURFACEFORMAT_R16G16_SSCALED << VE_FORMAT_SHIFT |
+		  0 << VE_OFFSET_SHIFT);
+	OUT_BATCH(COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT |
+		  COMPONENT_STORE_SRC << VE_COMPONENT_1_SHIFT |
+		  COMPONENT_STORE_0 << VE_COMPONENT_2_SHIFT |
+		  COMPONENT_STORE_1_FLT << VE_COMPONENT_3_SHIFT);
+
+	/* u0, v0, w0 */
+	DBG(("%s: first channel %d floats, offset=4\n", __FUNCTION__, id & 3));
+	dw = COMPONENT_STORE_1_FLT << VE_COMPONENT_3_SHIFT;
+	switch (id & 3) {
+	default:
+		assert(0);
+	case 0:
+		src_format = SURFACEFORMAT_R16G16_SSCALED;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_1_SHIFT;
+		dw |= COMPONENT_STORE_0 << VE_COMPONENT_2_SHIFT;
+		break;
+	case 1:
+		src_format = SURFACEFORMAT_R32_FLOAT;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT;
+		dw |= COMPONENT_STORE_0 << VE_COMPONENT_1_SHIFT;
+		dw |= COMPONENT_STORE_0 << VE_COMPONENT_2_SHIFT;
+		break;
+	case 2:
+		src_format = SURFACEFORMAT_R32G32_FLOAT;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_1_SHIFT;
+		dw |= COMPONENT_STORE_0 << VE_COMPONENT_2_SHIFT;
+		break;
+	case 3:
+		src_format = SURFACEFORMAT_R32G32B32_FLOAT;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_1_SHIFT;
+		dw |= COMPONENT_STORE_SRC << VE_COMPONENT_2_SHIFT;
+		break;
+	}
+	OUT_BATCH(id << VE_INDEX_SHIFT | VE_VALID |
+		  src_format << VE_FORMAT_SHIFT |
+		  4 << VE_OFFSET_SHIFT);
+	OUT_BATCH(dw);
+
+	/* u1, v1, w1 */
+	if (has_mask) {
+		unsigned offset = 4 + ((id & 3) ?: 1) * sizeof(float);
+		DBG(("%s: second channel %d floats, offset=%d\n", __FUNCTION__, (id >> 2) & 3, offset));
+		dw = COMPONENT_STORE_1_FLT << VE_COMPONENT_3_SHIFT;
+		switch (id >> 2) {
+		case 1:
+			src_format = SURFACEFORMAT_R32_FLOAT;
+			dw |= COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT;
+			dw |= COMPONENT_STORE_0 << VE_COMPONENT_1_SHIFT;
+			dw |= COMPONENT_STORE_0 << VE_COMPONENT_2_SHIFT;
+			break;
+		default:
+			assert(0);
+		case 2:
+			src_format = SURFACEFORMAT_R32G32_FLOAT;
+			dw |= COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT;
+			dw |= COMPONENT_STORE_SRC << VE_COMPONENT_1_SHIFT;
+			dw |= COMPONENT_STORE_0 << VE_COMPONENT_2_SHIFT;
+			break;
+		case 3:
+			src_format = SURFACEFORMAT_R32G32B32_FLOAT;
+			dw |= COMPONENT_STORE_SRC << VE_COMPONENT_0_SHIFT;
+			dw |= COMPONENT_STORE_SRC << VE_COMPONENT_1_SHIFT;
+			dw |= COMPONENT_STORE_SRC << VE_COMPONENT_2_SHIFT;
+			break;
+		}
+		OUT_BATCH(id << VE_INDEX_SHIFT | VE_VALID |
+			  src_format << VE_FORMAT_SHIFT |
+			  offset << VE_OFFSET_SHIFT);
+		OUT_BATCH(dw);
+	}
+}
+
+inline static void
+gen9_emit_pipe_invalidate(struct sna *sna)
+{
+	OUT_BATCH(GEN9_PIPE_CONTROL | (6 - 2));
+	OUT_BATCH(PIPE_CONTROL_WC_FLUSH |
+		  PIPE_CONTROL_TC_FLUSH |
+		  PIPE_CONTROL_CS_STALL);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+}
+
+inline static void
+gen9_emit_pipe_flush(struct sna *sna, bool need_stall)
+{
+	unsigned stall;
+
+	stall = 0;
+	if (need_stall)
+		stall = (PIPE_CONTROL_CS_STALL |
+			 PIPE_CONTROL_STALL_AT_SCOREBOARD);
+
+	OUT_BATCH(GEN9_PIPE_CONTROL | (6 - 2));
+	OUT_BATCH(PIPE_CONTROL_WC_FLUSH | stall);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+}
+
+inline static void
+gen9_emit_pipe_stall(struct sna *sna)
+{
+	OUT_BATCH(GEN9_PIPE_CONTROL | (6 - 2));
+	OUT_BATCH(PIPE_CONTROL_CS_STALL |
+		  PIPE_CONTROL_STALL_AT_SCOREBOARD);
+	OUT_BATCH64(0);
+	OUT_BATCH64(0);
+}
+
+static void
+gen9_emit_state(struct sna *sna,
+		const struct sna_composite_op *op,
+		uint16_t wm_binding_table)
+{
+	bool need_invalidate;
+	bool need_flush;
+	bool need_stall;
+
+	assert(op->dst.bo->exec);
+
+	need_flush = wm_binding_table & 1 ||
+		(sna->render_state.gen9.emit_flush && GEN9_READS_DST(op->u.gen9.flags));
+	if (ALWAYS_FLUSH)
+		need_flush = true;
+
+	wm_binding_table &= ~1;
+
+	need_stall = sna->render_state.gen9.surface_table != wm_binding_table;
+
+	need_invalidate = kgem_bo_is_dirty(op->src.bo) || kgem_bo_is_dirty(op->mask.bo);
+	if (ALWAYS_INVALIDATE)
+		need_invalidate = true;
+
+	need_stall &= gen9_emit_drawing_rectangle(sna, op);
+	if (ALWAYS_STALL)
+		need_stall = true;
+
+	if (need_invalidate) {
+		gen9_emit_pipe_invalidate(sna);
+		kgem_clear_dirty(&sna->kgem);
+		assert(op->dst.bo->exec);
+		kgem_bo_mark_dirty(op->dst.bo);
+
+		need_flush = false;
+		need_stall = false;
+	}
+	if (need_flush) {
+		gen9_emit_pipe_flush(sna, need_stall);
+		need_stall = false;
+	}
+	if (need_stall)
+		gen9_emit_pipe_stall(sna);
+
+	gen9_emit_cc(sna, GEN9_BLEND(op->u.gen9.flags));
+	gen9_emit_sampler(sna, GEN9_SAMPLER(op->u.gen9.flags));
+	gen9_emit_sf(sna, GEN9_VERTEX(op->u.gen9.flags) >> 2);
+	gen9_emit_wm(sna, GEN9_KERNEL(op->u.gen9.flags));
+	gen9_emit_vertex_elements(sna, op);
+	gen9_emit_binding_table(sna, wm_binding_table);
+
+	sna->render_state.gen9.emit_flush = GEN9_READS_DST(op->u.gen9.flags);
+}
+
+static bool gen9_magic_ca_pass(struct sna *sna,
+			       const struct sna_composite_op *op)
+{
+	struct gen9_render_state *state = &sna->render_state.gen9;
+
+	if (!op->need_magic_ca_pass)
+		return false;
+
+	DBG(("%s: CA fixup (%d -> %d)\n", __FUNCTION__,
+	     sna->render.vertex_start, sna->render.vertex_index));
+
+	gen9_emit_pipe_stall(sna);
+
+	gen9_emit_cc(sna,
+		     GEN9_BLEND(gen9_get_blend(PictOpAdd, true,
+					       op->dst.format)));
+	gen9_emit_wm(sna,
+		     gen9_choose_composite_kernel(PictOpAdd,
+						  true, true,
+						  op->is_affine));
+
+	OUT_BATCH(GEN9_3DPRIMITIVE | (7 - 2));
+	OUT_BATCH(0); /* ignored, see VF_TOPOLOGY */
+	OUT_BATCH(sna->render.vertex_index - sna->render.vertex_start);
+	OUT_BATCH(sna->render.vertex_start);
+	OUT_BATCH(1);	/* single instance */
+	OUT_BATCH(0);	/* start instance location */
+	OUT_BATCH(0);	/* index buffer offset, ignored */
+
+	state->last_primitive = sna->kgem.nbatch;
+	return true;
+}
+
+static void null_create(struct sna_static_stream *stream)
+{
+	/* A bunch of zeros useful for legacy border color and depth-stencil */
+	sna_static_stream_map(stream, 64, 64);
+}
+
+static void
+sampler_state_init(struct gen9_sampler_state *sampler_state,
+		   sampler_filter_t filter,
+		   sampler_extend_t extend)
+{
+	COMPILE_TIME_ASSERT(sizeof(*sampler_state) == 4*sizeof(uint32_t));
+
+	sampler_state->ss0.lod_preclamp = 2;	/* GL mode */
+	sampler_state->ss0.default_color_mode = 1;
+
+	switch (filter) {
+	default:
+	case SAMPLER_FILTER_NEAREST:
+		sampler_state->ss0.min_filter = MAPFILTER_NEAREST;
+		sampler_state->ss0.mag_filter = MAPFILTER_NEAREST;
+		break;
+	case SAMPLER_FILTER_BILINEAR:
+		sampler_state->ss0.min_filter = MAPFILTER_LINEAR;
+		sampler_state->ss0.mag_filter = MAPFILTER_LINEAR;
+		break;
+	}
+
+	/* XXX bicubic filter using MAPFILTER_FLEXIBLE */
+
+	switch (extend) {
+	default:
+	case SAMPLER_EXTEND_NONE:
+		sampler_state->ss3.r_wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
+		sampler_state->ss3.s_wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
+		sampler_state->ss3.t_wrap_mode = TEXCOORDMODE_CLAMP_BORDER;
+		break;
+	case SAMPLER_EXTEND_REPEAT:
+		sampler_state->ss3.r_wrap_mode = TEXCOORDMODE_WRAP;
+		sampler_state->ss3.s_wrap_mode = TEXCOORDMODE_WRAP;
+		sampler_state->ss3.t_wrap_mode = TEXCOORDMODE_WRAP;
+		break;
+	case SAMPLER_EXTEND_PAD:
+		sampler_state->ss3.r_wrap_mode = TEXCOORDMODE_CLAMP;
+		sampler_state->ss3.s_wrap_mode = TEXCOORDMODE_CLAMP;
+		sampler_state->ss3.t_wrap_mode = TEXCOORDMODE_CLAMP;
+		break;
+	case SAMPLER_EXTEND_REFLECT:
+		sampler_state->ss3.r_wrap_mode = TEXCOORDMODE_MIRROR;
+		sampler_state->ss3.s_wrap_mode = TEXCOORDMODE_MIRROR;
+		sampler_state->ss3.t_wrap_mode = TEXCOORDMODE_MIRROR;
+		break;
+	}
+}
+
+static void
+sampler_copy_init(struct gen9_sampler_state *ss)
+{
+	sampler_state_init(ss, SAMPLER_FILTER_NEAREST, SAMPLER_EXTEND_NONE);
+	ss->ss3.non_normalized_coord = 1;
+
+	sampler_state_init(ss+1, SAMPLER_FILTER_NEAREST, SAMPLER_EXTEND_NONE);
+}
+
+static void
+sampler_fill_init(struct gen9_sampler_state *ss)
+{
+	sampler_state_init(ss, SAMPLER_FILTER_NEAREST, SAMPLER_EXTEND_REPEAT);
+	ss->ss3.non_normalized_coord = 1;
+
+	sampler_state_init(ss+1, SAMPLER_FILTER_NEAREST, SAMPLER_EXTEND_NONE);
+}
+
+static uint32_t
+gen9_tiling_bits(uint32_t tiling)
+{
+	switch (tiling) {
+	default: assert(0);
+	case I915_TILING_NONE: return 0;
+	case I915_TILING_X: return SURFACE_TILED;
+	case I915_TILING_Y: return SURFACE_TILED | SURFACE_TILED_Y;
+	}
+}
+
+#define MOCS_PTE (1 << 1)
+#define MOCS_WB (2 << 1)
+
+/**
+ * Sets up the common fields for a surface state buffer for the given
+ * picture in the given surface state buffer.
+ */
+static uint32_t
+gen9_bind_bo(struct sna *sna,
+	     struct kgem_bo *bo,
+	     uint32_t width,
+	     uint32_t height,
+	     uint32_t format,
+	     bool is_dst)
+{
+	uint32_t *ss;
+	uint32_t domains;
+	int offset;
+	uint32_t is_scanout = is_dst && bo->scanout;
+
+	/* After the first bind, we manage the cache domains within the batch */
+	offset = kgem_bo_get_binding(bo, format | is_dst << 30 | is_scanout << 31);
+	if (offset) {
+		if (is_dst)
+			kgem_bo_mark_dirty(bo);
+		assert(offset >= sna->kgem.surface);
+		return offset * sizeof(uint32_t);
+	}
+
+	offset = sna->kgem.surface -= SURFACE_DW;
+	ss = sna->kgem.batch + offset;
+	ss[0] = (SURFACE_2D << SURFACE_TYPE_SHIFT |
+		 gen9_tiling_bits(bo->tiling) |
+		 format << SURFACE_FORMAT_SHIFT |
+		 SURFACE_VALIGN_4 | SURFACE_HALIGN_4);
+	if (is_dst) {
+		ss[0] |= SURFACE_RC_READ_WRITE;
+		domains = I915_GEM_DOMAIN_RENDER << 16 |I915_GEM_DOMAIN_RENDER;
+	} else
+		domains = I915_GEM_DOMAIN_SAMPLER << 16;
+	ss[1] = (is_dst && is_uncached(sna, bo)) ? 0 : is_scanout ? MOCS_PTE << 24 : MOCS_WB << 24;
+	ss[2] = ((width - 1)  << SURFACE_WIDTH_SHIFT |
+		 (height - 1) << SURFACE_HEIGHT_SHIFT);
+	ss[3] = (bo->pitch - 1) << SURFACE_PITCH_SHIFT;
+	ss[4] = 0;
+	ss[5] = 0;
+	ss[6] = 0;
+	ss[7] = SURFACE_SWIZZLE(RED, GREEN, BLUE, ALPHA);
+	*(uint64_t *)(ss+8) = kgem_add_reloc64(&sna->kgem, offset + 8, bo, domains, 0);
+	ss[10] = 0;
+	ss[11] = 0;
+	ss[12] = 0;
+	ss[13] = 0;
+	ss[14] = 0;
+	ss[15] = 0;
+
+	kgem_bo_set_binding(bo, format | is_dst << 30 | is_scanout << 31, offset);
+
+	DBG(("[%x] bind bo(handle=%d, addr=%lx), format=%d, width=%d, height=%d, pitch=%d, tiling=%d -> %s\n",
+	     offset, bo->handle, *(uint64_t *)(ss+8),
+	     format, width, height, bo->pitch, bo->tiling,
+	     domains & 0xffff ? "render" : "sampler"));
+
+	return offset * sizeof(uint32_t);
+}
+
+static void gen9_emit_vertex_buffer(struct sna *sna,
+				    const struct sna_composite_op *op)
+{
+	int id = GEN9_VERTEX(op->u.gen9.flags);
+
+	OUT_BATCH(GEN9_3DSTATE_VERTEX_BUFFERS | (5 - 2));
+	OUT_BATCH(id << VB_INDEX_SHIFT | VB_MODIFY_ENABLE |
+		  4*op->floats_per_vertex);
+	sna->render.vertex_reloc[sna->render.nvertex_reloc++] = sna->kgem.nbatch;
+	OUT_BATCH64(0);
+	OUT_BATCH(~0); /* buffer size: disabled */
+
+	sna->render.vb_id |= 1 << id;
+}
+
+static void gen9_emit_primitive(struct sna *sna)
+{
+	if (sna->kgem.nbatch == sna->render_state.gen9.last_primitive) {
+		sna->render.vertex_offset = sna->kgem.nbatch - 5;
+		return;
+	}
+
+	OUT_BATCH(GEN9_3DPRIMITIVE | (7 - 2));
+	OUT_BATCH(0); /* ignored, see VF_TOPOLOGY */
+	sna->render.vertex_offset = sna->kgem.nbatch;
+	OUT_BATCH(0);	/* vertex count, to be filled in later */
+	OUT_BATCH(sna->render.vertex_index);
+	OUT_BATCH(1);	/* single instance */
+	OUT_BATCH(0);	/* start instance location */
+	OUT_BATCH(0);	/* index buffer offset, ignored */
+	sna->render.vertex_start = sna->render.vertex_index;
+
+	sna->render_state.gen9.last_primitive = sna->kgem.nbatch;
+}
+
+static bool gen9_rectangle_begin(struct sna *sna,
+				 const struct sna_composite_op *op)
+{
+	int id = 1 << GEN9_VERTEX(op->u.gen9.flags);
+	int ndwords;
+
+	if (sna_vertex_wait__locked(&sna->render) && sna->render.vertex_offset)
+		return true;
+
+	ndwords = op->need_magic_ca_pass ? 60 : 6;
+	if ((sna->render.vb_id & id) == 0)
+		ndwords += 5;
+	if (!kgem_check_batch(&sna->kgem, ndwords))
+		return false;
+
+	if ((sna->render.vb_id & id) == 0)
+		gen9_emit_vertex_buffer(sna, op);
+
+	gen9_emit_primitive(sna);
+	return true;
+}
+
+static int gen9_get_rectangles__flush(struct sna *sna,
+				      const struct sna_composite_op *op)
+{
+	/* Preventing discarding new vbo after lock contention */
+	if (sna_vertex_wait__locked(&sna->render)) {
+		int rem = vertex_space(sna);
+		if (rem > op->floats_per_rect)
+			return rem;
+	}
+
+	if (!kgem_check_batch(&sna->kgem, op->need_magic_ca_pass ? 65 : 6))
+		return 0;
+	if (!kgem_check_reloc_and_exec(&sna->kgem, 2))
+		return 0;
+
+	if (sna->render.vertex_offset) {
+		gen8_vertex_flush(sna);
+		if (gen9_magic_ca_pass(sna, op)) {
+			gen9_emit_pipe_invalidate(sna);
+			gen9_emit_cc(sna, GEN9_BLEND(op->u.gen9.flags));
+			gen9_emit_wm(sna, GEN9_KERNEL(op->u.gen9.flags));
+		}
+	}
+
+	return gen8_vertex_finish(sna);
+}
+
+inline static int gen9_get_rectangles(struct sna *sna,
+				      const struct sna_composite_op *op,
+				      int want,
+				      void (*emit_state)(struct sna *sna, const struct sna_composite_op *op))
+{
+	int rem;
+
+	assert(want);
+
+start:
+	rem = vertex_space(sna);
+	if (unlikely(rem < op->floats_per_rect)) {
+		DBG(("flushing vbo for %s: %d < %d\n",
+		     __FUNCTION__, rem, op->floats_per_rect));
+		rem = gen9_get_rectangles__flush(sna, op);
+		if (unlikely(rem == 0))
+			goto flush;
+	}
+
+	if (unlikely(sna->render.vertex_offset == 0)) {
+		if (!gen9_rectangle_begin(sna, op))
+			goto flush;
+		else
+			goto start;
+	}
+
+	assert(rem <= vertex_space(sna));
+	assert(op->floats_per_rect <= rem);
+	if (want > 1 && want * op->floats_per_rect > rem)
+		want = rem / op->floats_per_rect;
+
+	assert(want > 0);
+	sna->render.vertex_index += 3*want;
+	return want;
+
+flush:
+	if (sna->render.vertex_offset) {
+		gen8_vertex_flush(sna);
+		gen9_magic_ca_pass(sna, op);
+	}
+	sna_vertex_wait__locked(&sna->render);
+	_kgem_submit(&sna->kgem);
+	emit_state(sna, op);
+	goto start;
+}
+
+inline static uint32_t *gen9_composite_get_binding_table(struct sna *sna,
+							 uint16_t *offset)
+{
+	uint32_t *table;
+
+	assert(sna->kgem.surface <= 16384);
+	sna->kgem.surface -= SURFACE_DW;
+	/* Clear all surplus entries to zero in case of prefetch */
+	table = memset(sna->kgem.batch + sna->kgem.surface, 0, 64);
+
+	DBG(("%s(%x)\n", __FUNCTION__, 4*sna->kgem.surface));
+
+	*offset = sna->kgem.surface;
+	return table;
+}
+
+static void
+gen9_get_batch(struct sna *sna, const struct sna_composite_op *op)
+{
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, op->dst.bo);
+
+	if (!kgem_check_batch_with_surfaces(&sna->kgem, 150, 2*(1+3))) {
+		DBG(("%s: flushing batch: %d < %d+%d\n",
+		     __FUNCTION__, sna->kgem.surface - sna->kgem.nbatch,
+		     150, 4*8*2));
+		_kgem_submit(&sna->kgem);
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	assert(sna->kgem.mode == KGEM_RENDER);
+	assert(sna->kgem.ring == KGEM_RENDER);
+
+	if (sna->render_state.gen9.needs_invariant)
+		gen9_emit_invariant(sna);
+}
+
+static void gen9_emit_composite_state(struct sna *sna,
+				      const struct sna_composite_op *op)
+{
+	uint32_t *binding_table;
+	uint16_t offset, dirty;
+
+	gen9_get_batch(sna, op);
+
+	binding_table = gen9_composite_get_binding_table(sna, &offset);
+
+	dirty = kgem_bo_is_dirty(op->dst.bo);
+
+	binding_table[0] =
+		gen9_bind_bo(sna,
+			    op->dst.bo, op->dst.width, op->dst.height,
+			    gen9_get_dest_format(op->dst.format),
+			    true);
+	binding_table[1] =
+		gen9_bind_bo(sna,
+			     op->src.bo, op->src.width, op->src.height,
+			     op->src.card_format,
+			     false);
+	if (op->mask.bo) {
+		binding_table[2] =
+			gen9_bind_bo(sna,
+				     op->mask.bo,
+				     op->mask.width,
+				     op->mask.height,
+				     op->mask.card_format,
+				     false);
+	}
+
+	if (sna->kgem.surface == offset &&
+	    *(uint64_t *)(sna->kgem.batch + sna->render_state.gen9.surface_table) == *(uint64_t*)binding_table &&
+	    (op->mask.bo == NULL ||
+	     sna->kgem.batch[sna->render_state.gen9.surface_table+2] == binding_table[2])) {
+		sna->kgem.surface += SURFACE_DW;
+		offset = sna->render_state.gen9.surface_table;
+	}
+
+	if (sna->kgem.batch[sna->render_state.gen9.surface_table] == binding_table[0])
+		dirty = 0;
+
+	gen9_emit_state(sna, op, offset | dirty);
+}
+
+static void
+gen9_align_vertex(struct sna *sna, const struct sna_composite_op *op)
+{
+	if (op->floats_per_vertex != sna->render_state.gen9.floats_per_vertex) {
+		DBG(("aligning vertex: was %d, now %d floats per vertex\n",
+		     sna->render_state.gen9.floats_per_vertex, op->floats_per_vertex));
+		gen8_vertex_align(sna, op);
+		sna->render_state.gen9.floats_per_vertex = op->floats_per_vertex;
+	}
+}
+
+fastcall static void
+gen9_render_composite_blt(struct sna *sna,
+			  const struct sna_composite_op *op,
+			  const struct sna_composite_rectangles *r)
+{
+	gen9_get_rectangles(sna, op, 1, gen9_emit_composite_state);
+	op->prim_emit(sna, op, r);
+}
+
+fastcall static void
+gen9_render_composite_box(struct sna *sna,
+			  const struct sna_composite_op *op,
+			  const BoxRec *box)
+{
+	struct sna_composite_rectangles r;
+
+	gen9_get_rectangles(sna, op, 1, gen9_emit_composite_state);
+
+	DBG(("  %s: (%d, %d), (%d, %d)\n",
+	     __FUNCTION__,
+	     box->x1, box->y1, box->x2, box->y2));
+
+	r.dst.x = box->x1;
+	r.dst.y = box->y1;
+	r.width  = box->x2 - box->x1;
+	r.height = box->y2 - box->y1;
+	r.src = r.mask = r.dst;
+
+	op->prim_emit(sna, op, &r);
+}
+
+static void
+gen9_render_composite_boxes__blt(struct sna *sna,
+				 const struct sna_composite_op *op,
+				 const BoxRec *box, int nbox)
+{
+	DBG(("composite_boxes(%d)\n", nbox));
+
+	do {
+		int nbox_this_time;
+
+		nbox_this_time = gen9_get_rectangles(sna, op, nbox,
+						     gen9_emit_composite_state);
+		nbox -= nbox_this_time;
+
+		do {
+			struct sna_composite_rectangles r;
+
+			DBG(("  %s: (%d, %d), (%d, %d)\n",
+			     __FUNCTION__,
+			     box->x1, box->y1, box->x2, box->y2));
+
+			r.dst.x = box->x1;
+			r.dst.y = box->y1;
+			r.width  = box->x2 - box->x1;
+			r.height = box->y2 - box->y1;
+			r.src = r.mask = r.dst;
+
+			op->prim_emit(sna, op, &r);
+			box++;
+		} while (--nbox_this_time);
+	} while (nbox);
+}
+
+static void
+gen9_render_composite_boxes(struct sna *sna,
+			    const struct sna_composite_op *op,
+			    const BoxRec *box, int nbox)
+{
+	DBG(("%s: nbox=%d\n", __FUNCTION__, nbox));
+
+	do {
+		int nbox_this_time;
+		float *v;
+
+		nbox_this_time = gen9_get_rectangles(sna, op, nbox,
+						     gen9_emit_composite_state);
+		assert(nbox_this_time);
+		nbox -= nbox_this_time;
+
+		v = sna->render.vertices + sna->render.vertex_used;
+		sna->render.vertex_used += nbox_this_time * op->floats_per_rect;
+
+		op->emit_boxes(op, box, nbox_this_time, v);
+		box += nbox_this_time;
+	} while (nbox);
+}
+
+static void
+gen9_render_composite_boxes__thread(struct sna *sna,
+				    const struct sna_composite_op *op,
+				    const BoxRec *box, int nbox)
+{
+	DBG(("%s: nbox=%d\n", __FUNCTION__, nbox));
+
+	sna_vertex_lock(&sna->render);
+	do {
+		int nbox_this_time;
+		float *v;
+
+		nbox_this_time = gen9_get_rectangles(sna, op, nbox,
+						     gen9_emit_composite_state);
+		assert(nbox_this_time);
+		nbox -= nbox_this_time;
+
+		v = sna->render.vertices + sna->render.vertex_used;
+		sna->render.vertex_used += nbox_this_time * op->floats_per_rect;
+
+		sna_vertex_acquire__locked(&sna->render);
+		sna_vertex_unlock(&sna->render);
+
+		op->emit_boxes(op, box, nbox_this_time, v);
+		box += nbox_this_time;
+
+		sna_vertex_lock(&sna->render);
+		sna_vertex_release__locked(&sna->render);
+	} while (nbox);
+	sna_vertex_unlock(&sna->render);
+}
+
+static uint32_t
+gen9_create_blend_state(struct sna_static_stream *stream)
+{
+	char *base, *ptr;
+	int src, dst;
+
+	COMPILE_TIME_ASSERT(((GEN9_BLENDFACTOR_COUNT * GEN9_BLENDFACTOR_COUNT << 4) & (1 << 15)) == 0);
+
+	base = sna_static_stream_map(stream,
+				     GEN9_BLENDFACTOR_COUNT * GEN9_BLENDFACTOR_COUNT * GEN9_BLEND_STATE_PADDED_SIZE,
+				     64);
+
+	ptr = base;
+	for (src = 0; src < GEN9_BLENDFACTOR_COUNT; src++) {
+		for (dst = 0; dst < GEN9_BLENDFACTOR_COUNT; dst++) {
+			struct gen9_blend_state *blend =
+				(struct gen9_blend_state *)ptr;
+
+			assert(((ptr - base) & 63) == 0);
+			COMPILE_TIME_ASSERT(sizeof(blend->common) == 4);
+			COMPILE_TIME_ASSERT(sizeof(blend->rt) == 8);
+			COMPILE_TIME_ASSERT((char *)&blend->rt - (char *)blend == 4);
+
+			blend->rt.post_blend_clamp = 1;
+			blend->rt.pre_blend_clamp = 1;
+
+			blend->rt.color_blend =
+				!(dst == BLENDFACTOR_ZERO && src == BLENDFACTOR_ONE);
+			blend->rt.dest_blend_factor = dst;
+			blend->rt.source_blend_factor = src;
+			blend->rt.color_blend_function = BLENDFUNCTION_ADD;
+
+			blend->rt.dest_alpha_blend_factor = dst;
+			blend->rt.source_alpha_blend_factor = src;
+			blend->rt.alpha_blend_function = BLENDFUNCTION_ADD;
+
+			ptr += GEN9_BLEND_STATE_PADDED_SIZE;
+		}
+	}
+
+	return sna_static_stream_offsetof(stream, base);
+}
+
+static int
+gen9_composite_picture(struct sna *sna,
+		       PicturePtr picture,
+		       struct sna_composite_channel *channel,
+		       int x, int y,
+		       int w, int h,
+		       int dst_x, int dst_y,
+		       bool precise)
+{
+	PixmapPtr pixmap;
+	uint32_t color;
+	int16_t dx, dy;
+
+	DBG(("%s: (%d, %d)x(%d, %d), dst=(%d, %d)\n",
+	     __FUNCTION__, x, y, w, h, dst_x, dst_y));
+
+	channel->is_solid = false;
+	channel->card_format = -1;
+
+	if (sna_picture_is_solid(picture, &color))
+		return gen4_channel_init_solid(sna, channel, color);
+
+	if (picture->pDrawable == NULL) {
+		int ret;
+
+		if (picture->pSourcePict->type == SourcePictTypeLinear)
+			return gen4_channel_init_linear(sna, picture, channel,
+							x, y,
+							w, h,
+							dst_x, dst_y);
+
+		DBG(("%s -- fixup, gradient\n", __FUNCTION__));
+		ret = -1;
+		if (!precise)
+			ret = sna_render_picture_approximate_gradient(sna, picture, channel,
+								      x, y, w, h, dst_x, dst_y);
+		if (ret == -1)
+			ret = sna_render_picture_fixup(sna, picture, channel,
+						       x, y, w, h, dst_x, dst_y);
+		return ret;
+	}
+
+	if (picture->alphaMap) {
+		DBG(("%s -- fallback, alphamap\n", __FUNCTION__));
+		return sna_render_picture_fixup(sna, picture, channel,
+						x, y, w, h, dst_x, dst_y);
+	}
+
+	if (!gen9_check_repeat(picture))
+		return sna_render_picture_fixup(sna, picture, channel,
+						x, y, w, h, dst_x, dst_y);
+
+	if (!gen9_check_filter(picture))
+		return sna_render_picture_fixup(sna, picture, channel,
+						x, y, w, h, dst_x, dst_y);
+
+	channel->repeat = picture->repeat ? picture->repeatType : RepeatNone;
+	channel->filter = picture->filter;
+
+	pixmap = get_drawable_pixmap(picture->pDrawable);
+	get_drawable_deltas(picture->pDrawable, pixmap, &dx, &dy);
+
+	x += dx + picture->pDrawable->x;
+	y += dy + picture->pDrawable->y;
+
+	channel->is_affine = sna_transform_is_affine(picture->transform);
+	if (sna_transform_is_imprecise_integer_translation(picture->transform, picture->filter, precise, &dx, &dy)) {
+		DBG(("%s: integer translation (%d, %d), removing\n",
+		     __FUNCTION__, dx, dy));
+		x += dx;
+		y += dy;
+		channel->transform = NULL;
+		channel->filter = PictFilterNearest;
+
+		if (channel->repeat ||
+		    (x >= 0 &&
+		     y >= 0 &&
+		     x + w <= pixmap->drawable.width &&
+		     y + h <= pixmap->drawable.height)) {
+			struct sna_pixmap *priv = sna_pixmap(pixmap);
+			if (priv && priv->clear) {
+				DBG(("%s: converting large pixmap source into solid [%08x]\n", __FUNCTION__, priv->clear_color));
+				return gen4_channel_init_solid(sna, channel, solid_color(picture->format, priv->clear_color));
+			}
+		}
+	} else
+		channel->transform = picture->transform;
+
+	channel->pict_format = picture->format;
+	channel->card_format = gen9_get_card_format(picture->format);
+	if (channel->card_format == (unsigned)-1)
+		return sna_render_picture_convert(sna, picture, channel, pixmap,
+						  x, y, w, h, dst_x, dst_y,
+						  false);
+
+	if (too_large(pixmap->drawable.width, pixmap->drawable.height)) {
+		DBG(("%s: extracting from pixmap %dx%d\n", __FUNCTION__,
+		     pixmap->drawable.width, pixmap->drawable.height));
+		return sna_render_picture_extract(sna, picture, channel,
+						  x, y, w, h, dst_x, dst_y);
+	}
+
+	return sna_render_pixmap_bo(sna, channel, pixmap,
+				    x, y, w, h, dst_x, dst_y);
+}
+
+inline static bool gen9_composite_channel_convert(struct sna_composite_channel *channel)
+{
+	if (unaligned(channel->bo, PICT_FORMAT_BPP(channel->pict_format)))
+		return false;
+
+	channel->repeat = gen9_repeat(channel->repeat);
+	channel->filter = gen9_filter(channel->filter);
+	if (channel->card_format == (unsigned)-1)
+		channel->card_format = gen9_get_card_format(channel->pict_format);
+	assert(channel->card_format != (unsigned)-1);
+
+	return true;
+}
+
+static void gen9_render_composite_done(struct sna *sna,
+				       const struct sna_composite_op *op)
+{
+	if (sna->render.vertex_offset) {
+		gen8_vertex_flush(sna);
+		gen9_magic_ca_pass(sna, op);
+	}
+
+	if (op->mask.bo)
+		kgem_bo_destroy(&sna->kgem, op->mask.bo);
+	if (op->src.bo)
+		kgem_bo_destroy(&sna->kgem, op->src.bo);
+
+	sna_render_composite_redirect_done(sna, op);
+}
+
+inline static bool
+gen9_composite_set_target(struct sna *sna,
+			  struct sna_composite_op *op,
+			  PicturePtr dst,
+			  int x, int y, int w, int h,
+			  bool partial)
+{
+	BoxRec box;
+	unsigned int hint;
+
+	DBG(("%s: (%d, %d)x(%d, %d), partial?=%d\n", __FUNCTION__, x, y, w, h, partial));
+
+	op->dst.pixmap = get_drawable_pixmap(dst->pDrawable);
+	op->dst.format = dst->format;
+	op->dst.width  = op->dst.pixmap->drawable.width;
+	op->dst.height = op->dst.pixmap->drawable.height;
+
+	if (w | h) {
+		assert(w && h);
+		box.x1 = x;
+		box.y1 = y;
+		box.x2 = x + w;
+		box.y2 = y + h;
+	} else
+		sna_render_picture_extents(dst, &box);
+
+	hint = PREFER_GPU | FORCE_GPU | RENDER_GPU;
+	if (!partial) {
+		hint |= IGNORE_DAMAGE;
+		if (w == op->dst.width && h == op->dst.height)
+			hint |= REPLACES;
+	}
+
+	op->dst.bo = sna_drawable_use_bo(dst->pDrawable, hint, &box, &op->damage);
+	if (op->dst.bo == NULL)
+		return false;
+
+	if (unaligned(op->dst.bo, dst->pDrawable->bitsPerPixel))
+		return false;
+
+	if (hint & REPLACES) {
+		struct sna_pixmap *priv = sna_pixmap(op->dst.pixmap);
+		kgem_bo_pair_undo(&sna->kgem, priv->gpu_bo, priv->cpu_bo);
+	}
+
+	get_drawable_deltas(dst->pDrawable, op->dst.pixmap,
+			    &op->dst.x, &op->dst.y);
+
+	DBG(("%s: pixmap=%ld, format=%08x, size=%dx%d, pitch=%d, delta=(%d,%d),damage=%p\n",
+	     __FUNCTION__,
+	     op->dst.pixmap->drawable.serialNumber, (int)op->dst.format,
+	     op->dst.width, op->dst.height,
+	     op->dst.bo->pitch,
+	     op->dst.x, op->dst.y,
+	     op->damage ? *op->damage : (void *)-1));
+
+	assert(op->dst.bo->proxy == NULL);
+
+	if (too_large(op->dst.width, op->dst.height) &&
+	    !sna_render_composite_redirect(sna, op, x, y, w, h, partial))
+		return false;
+
+	return true;
+}
+
+static bool
+try_blt(struct sna *sna,
+	uint8_t op,
+	PicturePtr src,
+	PicturePtr mask,
+	PicturePtr dst,
+	int16_t src_x, int16_t src_y,
+	int16_t msk_x, int16_t msk_y,
+	int16_t dst_x, int16_t dst_y,
+	int16_t width, int16_t height,
+	unsigned flags,
+	struct sna_composite_op *tmp)
+{
+	struct kgem_bo *bo;
+
+	if (sna->kgem.mode == KGEM_BLT) {
+		DBG(("%s: already performing BLT\n", __FUNCTION__));
+		goto execute;
+	}
+
+	if (too_large(width, height)) {
+		DBG(("%s: operation too large for 3D pipe (%d, %d)\n",
+		     __FUNCTION__, width, height));
+		goto execute;
+	}
+
+	bo = __sna_drawable_peek_bo(dst->pDrawable);
+	if (bo == NULL)
+		goto execute;
+
+	if (untiled_tlb_miss(bo))
+		goto execute;
+
+	if (bo->rq) {
+		if (RQ_IS_BLT(bo->rq))
+			goto execute;
+
+		return false;
+	}
+
+	if (bo->tiling == I915_TILING_Y)
+		goto upload;
+
+	if (sna_picture_is_solid(src, NULL) && can_switch_to_blt(sna, bo, 0))
+		goto execute;
+
+	if (src->pDrawable == dst->pDrawable &&
+	    (sna->render_state.gt < 3 || width*height < 1024) &&
+	    can_switch_to_blt(sna, bo, 0))
+		goto execute;
+
+	if (src->pDrawable) {
+		struct kgem_bo *s = __sna_drawable_peek_bo(src->pDrawable);
+		if (s == NULL)
+			goto upload;
+
+		if (prefer_blt_bo(sna, s, bo))
+			goto execute;
+	}
+
+	if (sna->kgem.ring == KGEM_BLT) {
+		DBG(("%s: already performing BLT\n", __FUNCTION__));
+		goto execute;
+	}
+
+upload:
+	flags |= COMPOSITE_UPLOAD;
+execute:
+	return sna_blt_composite(sna, op,
+				 src, dst,
+				 src_x, src_y,
+				 dst_x, dst_y,
+				 width, height,
+				 flags, tmp);
+}
+
+static bool
+check_gradient(PicturePtr picture, bool precise)
+{
+	if (picture->pDrawable)
+		return false;
+
+	switch (picture->pSourcePict->type) {
+	case SourcePictTypeSolidFill:
+	case SourcePictTypeLinear:
+		return false;
+	default:
+		return precise;
+	}
+}
+
+static bool
+has_alphamap(PicturePtr p)
+{
+	return p->alphaMap != NULL;
+}
+
+static bool
+need_upload(PicturePtr p)
+{
+	return p->pDrawable && unattached(p->pDrawable) && untransformed(p);
+}
+
+static bool
+source_is_busy(PixmapPtr pixmap)
+{
+	struct sna_pixmap *priv = sna_pixmap(pixmap);
+	if (priv == NULL || priv->clear)
+		return false;
+
+	if (priv->gpu_bo && kgem_bo_is_busy(priv->gpu_bo))
+		return true;
+
+	if (priv->cpu_bo && kgem_bo_is_busy(priv->cpu_bo))
+		return true;
+
+	return priv->gpu_damage && !priv->cpu_damage;
+}
+
+static bool
+source_fallback(PicturePtr p, PixmapPtr pixmap, bool precise)
+{
+	if (sna_picture_is_solid(p, NULL))
+		return false;
+
+	if (p->pSourcePict)
+		return check_gradient(p, precise);
+
+	if (!gen9_check_repeat(p) || !gen9_check_format(p->format))
+		return true;
+
+	if (pixmap && source_is_busy(pixmap))
+		return false;
+
+	return has_alphamap(p) || !gen9_check_filter(p) || need_upload(p);
+}
+
+static bool
+gen9_composite_fallback(struct sna *sna,
+			PicturePtr src,
+			PicturePtr mask,
+			PicturePtr dst)
+{
+	PixmapPtr src_pixmap;
+	PixmapPtr mask_pixmap;
+	PixmapPtr dst_pixmap;
+	bool src_fallback, mask_fallback;
+
+	if (!gen9_check_dst_format(dst->format)) {
+		DBG(("%s: unknown destination format: %d\n",
+		     __FUNCTION__, dst->format));
+		return true;
+	}
+
+	dst_pixmap = get_drawable_pixmap(dst->pDrawable);
+
+	src_pixmap = src->pDrawable ? get_drawable_pixmap(src->pDrawable) : NULL;
+	src_fallback = source_fallback(src, src_pixmap,
+				       dst->polyMode == PolyModePrecise);
+
+	if (mask) {
+		mask_pixmap = mask->pDrawable ? get_drawable_pixmap(mask->pDrawable) : NULL;
+		mask_fallback = source_fallback(mask, mask_pixmap,
+						dst->polyMode == PolyModePrecise);
+	} else {
+		mask_pixmap = NULL;
+		mask_fallback = false;
+	}
+
+	/* If we are using the destination as a source and need to
+	 * readback in order to upload the source, do it all
+	 * on the cpu.
+	 */
+	if (src_pixmap == dst_pixmap && src_fallback) {
+		DBG(("%s: src is dst and will fallback\n",__FUNCTION__));
+		return true;
+	}
+	if (mask_pixmap == dst_pixmap && mask_fallback) {
+		DBG(("%s: mask is dst and will fallback\n",__FUNCTION__));
+		return true;
+	}
+
+	/* If anything is on the GPU, push everything out to the GPU */
+	if (dst_use_gpu(dst_pixmap)) {
+		DBG(("%s: dst is already on the GPU, try to use GPU\n",
+		     __FUNCTION__));
+		return false;
+	}
+
+	if (src_pixmap && !src_fallback) {
+		DBG(("%s: src is already on the GPU, try to use GPU\n",
+		     __FUNCTION__));
+		return false;
+	}
+	if (mask_pixmap && !mask_fallback) {
+		DBG(("%s: mask is already on the GPU, try to use GPU\n",
+		     __FUNCTION__));
+		return false;
+	}
+
+	/* However if the dst is not on the GPU and we need to
+	 * render one of the sources using the CPU, we may
+	 * as well do the entire operation in place onthe CPU.
+	 */
+	if (src_fallback) {
+		DBG(("%s: dst is on the CPU and src will fallback\n",
+		     __FUNCTION__));
+		return true;
+	}
+
+	if (mask && mask_fallback) {
+		DBG(("%s: dst is on the CPU and mask will fallback\n",
+		     __FUNCTION__));
+		return true;
+	}
+
+	if (too_large(dst_pixmap->drawable.width,
+		      dst_pixmap->drawable.height) &&
+	    dst_is_cpu(dst_pixmap)) {
+		DBG(("%s: dst is on the CPU and too large\n", __FUNCTION__));
+		return true;
+	}
+
+	DBG(("%s: dst is not on the GPU and the operation should not fallback\n",
+	     __FUNCTION__));
+	return dst_use_cpu(dst_pixmap);
+}
+
+static int
+reuse_source(struct sna *sna,
+	     PicturePtr src, struct sna_composite_channel *sc, int src_x, int src_y,
+	     PicturePtr mask, struct sna_composite_channel *mc, int msk_x, int msk_y)
+{
+	uint32_t color;
+
+	if (src_x != msk_x || src_y != msk_y)
+		return false;
+
+	if (src == mask) {
+		DBG(("%s: mask is source\n", __FUNCTION__));
+		*mc = *sc;
+		mc->bo = kgem_bo_reference(mc->bo);
+		return true;
+	}
+
+	if (sna_picture_is_solid(mask, &color))
+		return gen4_channel_init_solid(sna, mc, color);
+
+	if (sc->is_solid)
+		return false;
+
+	if (src->pDrawable == NULL || mask->pDrawable != src->pDrawable)
+		return false;
+
+	DBG(("%s: mask reuses source drawable\n", __FUNCTION__));
+
+	if (!sna_transform_equal(src->transform, mask->transform))
+		return false;
+
+	if (!sna_picture_alphamap_equal(src, mask))
+		return false;
+
+	if (!gen9_check_repeat(mask))
+		return false;
+
+	if (!gen9_check_filter(mask))
+		return false;
+
+	if (!gen9_check_format(mask->format))
+		return false;
+
+	DBG(("%s: reusing source channel for mask with a twist\n",
+	     __FUNCTION__));
+
+	*mc = *sc;
+	mc->repeat = gen9_repeat(mask->repeat ? mask->repeatType : RepeatNone);
+	mc->filter = gen9_filter(mask->filter);
+	mc->pict_format = mask->format;
+	mc->card_format = gen9_get_card_format(mask->format);
+	mc->bo = kgem_bo_reference(mc->bo);
+	return true;
+}
+
+static bool
+gen9_render_composite(struct sna *sna,
+		      uint8_t op,
+		      PicturePtr src,
+		      PicturePtr mask,
+		      PicturePtr dst,
+		      int16_t src_x, int16_t src_y,
+		      int16_t msk_x, int16_t msk_y,
+		      int16_t dst_x, int16_t dst_y,
+		      int16_t width, int16_t height,
+		      unsigned flags,
+		      struct sna_composite_op *tmp)
+{
+	if (op >= ARRAY_SIZE(gen9_blend_op))
+		return false;
+
+	DBG(("%s: %dx%d, current mode=%d/%d\n", __FUNCTION__,
+	     width, height, sna->kgem.mode, sna->kgem.ring));
+
+	if (mask == NULL &&
+	    try_blt(sna, op,
+		    src, mask, dst,
+		    src_x, src_y,
+		    msk_x, msk_y,
+		    dst_x, dst_y,
+		    width, height,
+		    flags, tmp))
+		return true;
+
+	if (gen9_composite_fallback(sna, src, mask, dst))
+		goto fallback;
+
+	if (need_tiling(sna, width, height))
+		return sna_tiling_composite(op, src, mask, dst,
+					    src_x, src_y,
+					    msk_x, msk_y,
+					    dst_x, dst_y,
+					    width, height,
+					    tmp);
+
+	if (op == PictOpClear && src == sna->clear)
+		op = PictOpSrc;
+	tmp->op = op;
+	if (!gen9_composite_set_target(sna, tmp, dst,
+				       dst_x, dst_y, width, height,
+				       flags & COMPOSITE_PARTIAL || op > PictOpSrc))
+		goto fallback;
+
+	switch (gen9_composite_picture(sna, src, &tmp->src,
+				       src_x, src_y,
+				       width, height,
+				       dst_x, dst_y,
+				       dst->polyMode == PolyModePrecise)) {
+	case -1:
+		goto cleanup_dst;
+	case 0:
+		if (!gen4_channel_init_solid(sna, &tmp->src, 0))
+			goto cleanup_dst;
+		/* fall through to fixup */
+	case 1:
+		/* Did we just switch rings to prepare the source? */
+		if (mask == NULL &&
+		    (prefer_blt_composite(sna, tmp) ||
+		     unaligned(tmp->src.bo, PICT_FORMAT_BPP(tmp->src.pict_format))) &&
+		    sna_blt_composite__convert(sna,
+					       dst_x, dst_y, width, height,
+					       tmp))
+			return true;
+
+		if (!gen9_composite_channel_convert(&tmp->src))
+			goto cleanup_src;
+
+		break;
+	}
+
+	tmp->is_affine = tmp->src.is_affine;
+	tmp->has_component_alpha = false;
+	tmp->need_magic_ca_pass = false;
+
+	tmp->mask.bo = NULL;
+	tmp->mask.filter = SAMPLER_FILTER_NEAREST;
+	tmp->mask.repeat = SAMPLER_EXTEND_NONE;
+
+	if (mask) {
+		if (mask->componentAlpha && PICT_FORMAT_RGB(mask->format)) {
+			tmp->has_component_alpha = true;
+
+			/* Check if it's component alpha that relies on a source alpha and on
+			 * the source value.  We can only get one of those into the single
+			 * source value that we get to blend with.
+			 */
+			if (gen9_blend_op[op].src_alpha &&
+			    (gen9_blend_op[op].src_blend != BLENDFACTOR_ZERO)) {
+				if (op != PictOpOver)
+					goto cleanup_src;
+
+				tmp->need_magic_ca_pass = true;
+				tmp->op = PictOpOutReverse;
+			}
+		}
+
+		if (!reuse_source(sna,
+				  src, &tmp->src, src_x, src_y,
+				  mask, &tmp->mask, msk_x, msk_y)) {
+			switch (gen9_composite_picture(sna, mask, &tmp->mask,
+						       msk_x, msk_y,
+						       width, height,
+						       dst_x, dst_y,
+						       dst->polyMode == PolyModePrecise)) {
+			case -1:
+				goto cleanup_src;
+			case 0:
+				if (!gen4_channel_init_solid(sna, &tmp->mask, 0))
+					goto cleanup_src;
+				/* fall through to fixup */
+			case 1:
+				if (!gen9_composite_channel_convert(&tmp->mask))
+					goto cleanup_mask;
+				break;
+			}
+		}
+
+		tmp->is_affine &= tmp->mask.is_affine;
+	}
+
+	tmp->u.gen9.flags =
+		GEN9_SET_FLAGS(SAMPLER_OFFSET(tmp->src.filter,
+					      tmp->src.repeat,
+					      tmp->mask.filter,
+					      tmp->mask.repeat),
+			       gen9_get_blend(tmp->op,
+					      tmp->has_component_alpha,
+					      tmp->dst.format),
+			       gen9_choose_composite_kernel(tmp->op,
+							    tmp->mask.bo != NULL,
+							    tmp->has_component_alpha,
+							    tmp->is_affine),
+			       gen4_choose_composite_emitter(sna, tmp));
+
+	tmp->blt   = gen9_render_composite_blt;
+	tmp->box   = gen9_render_composite_box;
+	tmp->boxes = gen9_render_composite_boxes__blt;
+	if (tmp->emit_boxes){
+		tmp->boxes = gen9_render_composite_boxes;
+		tmp->thread_boxes = gen9_render_composite_boxes__thread;
+	}
+	tmp->done  = gen9_render_composite_done;
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, tmp->dst.bo);
+	if (!kgem_check_bo(&sna->kgem,
+			   tmp->dst.bo, tmp->src.bo, tmp->mask.bo,
+			   NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem,
+				   tmp->dst.bo, tmp->src.bo, tmp->mask.bo,
+				   NULL))
+			goto cleanup_mask;
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, tmp);
+	gen9_emit_composite_state(sna, tmp);
+	return true;
+
+cleanup_mask:
+	if (tmp->mask.bo) {
+		kgem_bo_destroy(&sna->kgem, tmp->mask.bo);
+		tmp->mask.bo = NULL;
+	}
+cleanup_src:
+	if (tmp->src.bo) {
+		kgem_bo_destroy(&sna->kgem, tmp->src.bo);
+		tmp->src.bo = NULL;
+	}
+cleanup_dst:
+	if (tmp->redirect.real_bo) {
+		kgem_bo_destroy(&sna->kgem, tmp->dst.bo);
+		tmp->redirect.real_bo = NULL;
+	}
+fallback:
+	return (mask == NULL &&
+		sna_blt_composite(sna, op,
+				  src, dst,
+				  src_x, src_y,
+				  dst_x, dst_y,
+				  width, height,
+				  flags | COMPOSITE_FALLBACK, tmp));
+}
+
+#if !NO_COMPOSITE_SPANS
+fastcall static void
+gen9_render_composite_spans_box(struct sna *sna,
+				const struct sna_composite_spans_op *op,
+				const BoxRec *box, float opacity)
+{
+	DBG(("%s: src=+(%d, %d), opacity=%f, dst=+(%d, %d), box=(%d, %d) x (%d, %d)\n",
+	     __FUNCTION__,
+	     op->base.src.offset[0], op->base.src.offset[1],
+	     opacity,
+	     op->base.dst.x, op->base.dst.y,
+	     box->x1, box->y1,
+	     box->x2 - box->x1,
+	     box->y2 - box->y1));
+
+	gen9_get_rectangles(sna, &op->base, 1, gen9_emit_composite_state);
+	op->prim_emit(sna, op, box, opacity);
+}
+
+static void
+gen9_render_composite_spans_boxes(struct sna *sna,
+				  const struct sna_composite_spans_op *op,
+				  const BoxRec *box, int nbox,
+				  float opacity)
+{
+	DBG(("%s: nbox=%d, src=+(%d, %d), opacity=%f, dst=+(%d, %d)\n",
+	     __FUNCTION__, nbox,
+	     op->base.src.offset[0], op->base.src.offset[1],
+	     opacity,
+	     op->base.dst.x, op->base.dst.y));
+
+	do {
+		int nbox_this_time;
+
+		nbox_this_time = gen9_get_rectangles(sna, &op->base, nbox,
+						     gen9_emit_composite_state);
+		nbox -= nbox_this_time;
+
+		do {
+			DBG(("  %s: (%d, %d) x (%d, %d)\n", __FUNCTION__,
+			     box->x1, box->y1,
+			     box->x2 - box->x1,
+			     box->y2 - box->y1));
+
+			op->prim_emit(sna, op, box++, opacity);
+		} while (--nbox_this_time);
+	} while (nbox);
+}
+
+fastcall static void
+gen9_render_composite_spans_boxes__thread(struct sna *sna,
+					  const struct sna_composite_spans_op *op,
+					  const struct sna_opacity_box *box,
+					  int nbox)
+{
+	DBG(("%s: nbox=%d, src=+(%d, %d), dst=+(%d, %d)\n",
+	     __FUNCTION__, nbox,
+	     op->base.src.offset[0], op->base.src.offset[1],
+	     op->base.dst.x, op->base.dst.y));
+
+	sna_vertex_lock(&sna->render);
+	do {
+		int nbox_this_time;
+		float *v;
+
+		nbox_this_time = gen9_get_rectangles(sna, &op->base, nbox,
+						     gen9_emit_composite_state);
+		assert(nbox_this_time);
+		nbox -= nbox_this_time;
+
+		v = sna->render.vertices + sna->render.vertex_used;
+		sna->render.vertex_used += nbox_this_time * op->base.floats_per_rect;
+
+		sna_vertex_acquire__locked(&sna->render);
+		sna_vertex_unlock(&sna->render);
+
+		op->emit_boxes(op, box, nbox_this_time, v);
+		box += nbox_this_time;
+
+		sna_vertex_lock(&sna->render);
+		sna_vertex_release__locked(&sna->render);
+	} while (nbox);
+	sna_vertex_unlock(&sna->render);
+}
+
+fastcall static void
+gen9_render_composite_spans_done(struct sna *sna,
+				 const struct sna_composite_spans_op *op)
+{
+	if (sna->render.vertex_offset)
+		gen8_vertex_flush(sna);
+
+	DBG(("%s()\n", __FUNCTION__));
+
+	if (op->base.src.bo)
+		kgem_bo_destroy(&sna->kgem, op->base.src.bo);
+
+	sna_render_composite_redirect_done(sna, &op->base);
+}
+
+static bool
+gen9_check_composite_spans(struct sna *sna,
+			   uint8_t op, PicturePtr src, PicturePtr dst,
+			   int16_t width, int16_t height, unsigned flags)
+{
+	if (op >= ARRAY_SIZE(gen9_blend_op))
+		return false;
+
+	if (gen9_composite_fallback(sna, src, NULL, dst))
+		return false;
+
+	if (need_tiling(sna, width, height) &&
+	    !is_gpu(sna, dst->pDrawable, PREFER_GPU_SPANS)) {
+		DBG(("%s: fallback, tiled operation not on GPU\n",
+		     __FUNCTION__));
+		return false;
+	}
+
+	return true;
+}
+
+static bool
+gen9_render_composite_spans(struct sna *sna,
+			    uint8_t op,
+			    PicturePtr src,
+			    PicturePtr dst,
+			    int16_t src_x,  int16_t src_y,
+			    int16_t dst_x,  int16_t dst_y,
+			    int16_t width,  int16_t height,
+			    unsigned flags,
+			    struct sna_composite_spans_op *tmp)
+{
+	DBG(("%s: %dx%d with flags=%x, current mode=%d\n", __FUNCTION__,
+	     width, height, flags, sna->kgem.ring));
+
+	assert(gen9_check_composite_spans(sna, op, src, dst, width, height, flags));
+
+	if (need_tiling(sna, width, height)) {
+		DBG(("%s: tiling, operation (%dx%d) too wide for pipeline\n",
+		     __FUNCTION__, width, height));
+		return sna_tiling_composite_spans(op, src, dst,
+						  src_x, src_y, dst_x, dst_y,
+						  width, height, flags, tmp);
+	}
+
+	tmp->base.op = op;
+	if (!gen9_composite_set_target(sna, &tmp->base, dst,
+				       dst_x, dst_y, width, height, true))
+		return false;
+
+	switch (gen9_composite_picture(sna, src, &tmp->base.src,
+				       src_x, src_y,
+				       width, height,
+				       dst_x, dst_y,
+				       dst->polyMode == PolyModePrecise)) {
+	case -1:
+		goto cleanup_dst;
+	case 0:
+		if (!gen4_channel_init_solid(sna, &tmp->base.src, 0))
+			goto cleanup_dst;
+		/* fall through to fixup */
+	case 1:
+		if (!gen9_composite_channel_convert(&tmp->base.src))
+			goto cleanup_src;
+		break;
+	}
+	tmp->base.mask.bo = NULL;
+
+	tmp->base.is_affine = tmp->base.src.is_affine;
+	tmp->base.need_magic_ca_pass = false;
+
+	tmp->base.u.gen9.flags =
+		GEN9_SET_FLAGS(SAMPLER_OFFSET(tmp->base.src.filter,
+					      tmp->base.src.repeat,
+					      SAMPLER_FILTER_NEAREST,
+					      SAMPLER_EXTEND_PAD),
+			       gen9_get_blend(tmp->base.op, false, tmp->base.dst.format),
+			       GEN9_WM_KERNEL_OPACITY | !tmp->base.is_affine,
+			       gen4_choose_spans_emitter(sna, tmp));
+
+	tmp->box   = gen9_render_composite_spans_box;
+	tmp->boxes = gen9_render_composite_spans_boxes;
+	if (tmp->emit_boxes)
+		tmp->thread_boxes = gen9_render_composite_spans_boxes__thread;
+	tmp->done  = gen9_render_composite_spans_done;
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, tmp->base.dst.bo);
+	if (!kgem_check_bo(&sna->kgem,
+			   tmp->base.dst.bo, tmp->base.src.bo,
+			   NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem,
+				   tmp->base.dst.bo, tmp->base.src.bo,
+				   NULL))
+			goto cleanup_src;
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, &tmp->base);
+	gen9_emit_composite_state(sna, &tmp->base);
+	return true;
+
+cleanup_src:
+	if (tmp->base.src.bo)
+		kgem_bo_destroy(&sna->kgem, tmp->base.src.bo);
+cleanup_dst:
+	if (tmp->base.redirect.real_bo)
+		kgem_bo_destroy(&sna->kgem, tmp->base.dst.bo);
+	return false;
+}
+#endif
+
+static void
+gen9_emit_copy_state(struct sna *sna,
+		     const struct sna_composite_op *op)
+{
+	uint32_t *binding_table;
+	uint16_t offset, dirty;
+
+	gen9_get_batch(sna, op);
+
+	binding_table = gen9_composite_get_binding_table(sna, &offset);
+
+	dirty = kgem_bo_is_dirty(op->dst.bo);
+
+	binding_table[0] =
+		gen9_bind_bo(sna,
+			     op->dst.bo, op->dst.width, op->dst.height,
+			     gen9_get_dest_format(op->dst.format),
+			     true);
+	binding_table[1] =
+		gen9_bind_bo(sna,
+			     op->src.bo, op->src.width, op->src.height,
+			     op->src.card_format,
+			     false);
+
+	if (sna->kgem.surface == offset &&
+	    *(uint64_t *)(sna->kgem.batch + sna->render_state.gen9.surface_table) == *(uint64_t*)binding_table) {
+		sna->kgem.surface += SURFACE_DW;
+		offset = sna->render_state.gen9.surface_table;
+	}
+
+	if (sna->kgem.batch[sna->render_state.gen9.surface_table] == binding_table[0])
+		dirty = 0;
+
+	assert(!GEN9_READS_DST(op->u.gen9.flags));
+	gen9_emit_state(sna, op, offset | dirty);
+}
+
+static inline bool
+prefer_blt_copy(struct sna *sna,
+		struct kgem_bo *src_bo,
+		struct kgem_bo *dst_bo,
+		unsigned flags)
+{
+	if (sna->kgem.mode == KGEM_BLT)
+		return true;
+
+	assert((flags & COPY_SYNC) == 0);
+
+	if (untiled_tlb_miss(src_bo) ||
+	    untiled_tlb_miss(dst_bo))
+		return true;
+
+	if (flags & COPY_DRI && !sna->kgem.has_semaphores)
+		return false;
+
+	if (force_blt_ring(sna, dst_bo))
+		return true;
+
+	if ((flags & COPY_SMALL ||
+	     (sna->render_state.gt < 3 && src_bo == dst_bo)) &&
+	    can_switch_to_blt(sna, dst_bo, flags))
+		return true;
+
+	if (kgem_bo_is_render(dst_bo) ||
+	    kgem_bo_is_render(src_bo))
+		return false;
+
+	if (flags & COPY_LAST &&
+	    sna->render_state.gt < 3 &&
+            can_switch_to_blt(sna, dst_bo, flags))
+		return true;
+
+	if (prefer_render_ring(sna, dst_bo))
+		return false;
+
+	if (!prefer_blt_ring(sna, dst_bo, flags))
+		return false;
+
+	return prefer_blt_bo(sna, src_bo, dst_bo);
+}
+
+static bool
+gen9_render_copy_boxes(struct sna *sna, uint8_t alu,
+		       const DrawableRec *src, struct kgem_bo *src_bo, int16_t src_dx, int16_t src_dy,
+		       const DrawableRec *dst, struct kgem_bo *dst_bo, int16_t dst_dx, int16_t dst_dy,
+		       const BoxRec *box, int n, unsigned flags)
+{
+	struct sna_composite_op tmp;
+	BoxRec extents;
+
+	DBG(("%s (%d, %d)->(%d, %d) x %d, alu=%x, flags=%x, self-copy=%d, overlaps? %d\n",
+	     __FUNCTION__, src_dx, src_dy, dst_dx, dst_dy, n, alu, flags,
+	     src_bo == dst_bo,
+	     overlaps(sna,
+		      src_bo, src_dx, src_dy,
+		      dst_bo, dst_dx, dst_dy,
+		      box, n, flags, &extents)));
+
+	if (prefer_blt_copy(sna, src_bo, dst_bo, flags) &&
+	    sna_blt_compare_depth(src, dst) &&
+	    sna_blt_copy_boxes(sna, alu,
+			       src_bo, src_dx, src_dy,
+			       dst_bo, dst_dx, dst_dy,
+			       dst->bitsPerPixel,
+			       box, n))
+		return true;
+
+	if (!(alu == GXcopy || alu == GXclear) ||
+	    unaligned(src_bo, src->bitsPerPixel) ||
+	    unaligned(dst_bo, dst->bitsPerPixel)) {
+fallback_blt:
+		DBG(("%s: fallback blt\n", __FUNCTION__));
+		if (!sna_blt_compare_depth(src, dst))
+			return false;
+
+		return sna_blt_copy_boxes_fallback(sna, alu,
+						   src, src_bo, src_dx, src_dy,
+						   dst, dst_bo, dst_dx, dst_dy,
+						   box, n);
+	}
+
+	if (overlaps(sna,
+		     src_bo, src_dx, src_dy,
+		     dst_bo, dst_dx, dst_dy,
+		     box, n, flags,
+		     &extents)) {
+		bool big = too_large(extents.x2-extents.x1, extents.y2-extents.y1);
+
+		if ((big || !prefer_render_ring(sna, dst_bo)) &&
+		    sna_blt_copy_boxes(sna, alu,
+				       src_bo, src_dx, src_dy,
+				       dst_bo, dst_dx, dst_dy,
+				       dst->bitsPerPixel,
+				       box, n))
+			return true;
+
+		if (big)
+			goto fallback_blt;
+
+		assert(src_bo == dst_bo);
+		assert(src->depth == dst->depth);
+		assert(src->width == dst->width);
+		assert(src->height == dst->height);
+		return sna_render_copy_boxes__overlap(sna, alu, dst, dst_bo,
+						      src_dx, src_dy,
+						      dst_dx, dst_dy,
+						      box, n, &extents);
+	}
+
+	if (dst->depth == src->depth) {
+		tmp.dst.format = sna_render_format_for_depth(dst->depth);
+		tmp.src.pict_format = tmp.dst.format;
+	} else {
+		tmp.dst.format = sna_format_for_depth(dst->depth);
+		tmp.src.pict_format = sna_format_for_depth(src->depth);
+	}
+	if (!gen9_check_format(tmp.src.pict_format))
+		goto fallback_blt;
+
+	tmp.dst.pixmap = (PixmapPtr)dst;
+	tmp.dst.width  = dst->width;
+	tmp.dst.height = dst->height;
+	tmp.dst.bo = dst_bo;
+	tmp.dst.x = tmp.dst.y = 0;
+	tmp.damage = NULL;
+
+	sna_render_composite_redirect_init(&tmp);
+	if (too_large(tmp.dst.width, tmp.dst.height)) {
+		int i;
+
+		extents = box[0];
+		for (i = 1; i < n; i++) {
+			if (box[i].x1 < extents.x1)
+				extents.x1 = box[i].x1;
+			if (box[i].y1 < extents.y1)
+				extents.y1 = box[i].y1;
+
+			if (box[i].x2 > extents.x2)
+				extents.x2 = box[i].x2;
+			if (box[i].y2 > extents.y2)
+				extents.y2 = box[i].y2;
+		}
+
+		if (!sna_render_composite_redirect(sna, &tmp,
+						   extents.x1 + dst_dx,
+						   extents.y1 + dst_dy,
+						   extents.x2 - extents.x1,
+						   extents.y2 - extents.y1,
+						   n > 1))
+			goto fallback_tiled;
+	}
+
+	tmp.src.card_format = gen9_get_card_format(tmp.src.pict_format);
+	if (too_large(src->width, src->height)) {
+		int i;
+
+		extents = box[0];
+		for (i = 1; i < n; i++) {
+			if (box[i].x1 < extents.x1)
+				extents.x1 = box[i].x1;
+			if (box[i].y1 < extents.y1)
+				extents.y1 = box[i].y1;
+
+			if (box[i].x2 > extents.x2)
+				extents.x2 = box[i].x2;
+			if (box[i].y2 > extents.y2)
+				extents.y2 = box[i].y2;
+		}
+
+		if (!sna_render_pixmap_partial(sna, src, src_bo, &tmp.src,
+					       extents.x1 + src_dx,
+					       extents.y1 + src_dy,
+					       extents.x2 - extents.x1,
+					       extents.y2 - extents.y1))
+			goto fallback_tiled_dst;
+	} else {
+		tmp.src.bo = src_bo;
+		tmp.src.width  = src->width;
+		tmp.src.height = src->height;
+		tmp.src.offset[0] = tmp.src.offset[1] = 0;
+	}
+
+	tmp.mask.bo = NULL;
+
+	tmp.floats_per_vertex = 2;
+	tmp.floats_per_rect = 6;
+	tmp.need_magic_ca_pass = 0;
+
+	tmp.u.gen9.flags = COPY_FLAGS(alu);
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, tmp.dst.bo);
+	if (!kgem_check_bo(&sna->kgem, tmp.dst.bo, tmp.src.bo, NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem, tmp.dst.bo, tmp.src.bo, NULL)) {
+			if (tmp.src.bo != src_bo)
+				kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+			if (tmp.redirect.real_bo)
+				kgem_bo_destroy(&sna->kgem, tmp.dst.bo);
+			goto fallback_blt;
+		}
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	src_dx += tmp.src.offset[0];
+	src_dy += tmp.src.offset[1];
+
+	dst_dx += tmp.dst.x;
+	dst_dy += tmp.dst.y;
+
+	tmp.dst.x = tmp.dst.y = 0;
+
+	gen9_align_vertex(sna, &tmp);
+	gen9_emit_copy_state(sna, &tmp);
+
+	do {
+		int16_t *v;
+		int n_this_time;
+
+		n_this_time = gen9_get_rectangles(sna, &tmp, n,
+						  gen9_emit_copy_state);
+		n -= n_this_time;
+
+		v = (int16_t *)(sna->render.vertices + sna->render.vertex_used);
+		sna->render.vertex_used += 6 * n_this_time;
+		assert(sna->render.vertex_used <= sna->render.vertex_size);
+		do {
+
+			DBG(("	(%d, %d) -> (%d, %d) + (%d, %d)\n",
+			     box->x1 + src_dx, box->y1 + src_dy,
+			     box->x1 + dst_dx, box->y1 + dst_dy,
+			     box->x2 - box->x1, box->y2 - box->y1));
+			v[0] = box->x2 + dst_dx;
+			v[2] = box->x2 + src_dx;
+			v[1]  = v[5] = box->y2 + dst_dy;
+			v[3]  = v[7] = box->y2 + src_dy;
+			v[8]  = v[4] = box->x1 + dst_dx;
+			v[10] = v[6] = box->x1 + src_dx;
+			v[9]  = box->y1 + dst_dy;
+			v[11] = box->y1 + src_dy;
+			v += 12; box++;
+		} while (--n_this_time);
+	} while (n);
+
+	gen8_vertex_flush(sna);
+	sna_render_composite_redirect_done(sna, &tmp);
+	if (tmp.src.bo != src_bo)
+		kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+	return true;
+
+fallback_tiled_dst:
+	if (tmp.redirect.real_bo)
+		kgem_bo_destroy(&sna->kgem, tmp.dst.bo);
+fallback_tiled:
+	DBG(("%s: fallback tiled\n", __FUNCTION__));
+	if (sna_blt_compare_depth(src, dst) &&
+	    sna_blt_copy_boxes(sna, alu,
+			       src_bo, src_dx, src_dy,
+			       dst_bo, dst_dx, dst_dy,
+			       dst->bitsPerPixel,
+			       box, n))
+		return true;
+
+	return sna_tiling_copy_boxes(sna, alu,
+				     src, src_bo, src_dx, src_dy,
+				     dst, dst_bo, dst_dx, dst_dy,
+				     box, n);
+}
+
+static void
+gen9_render_copy_blt(struct sna *sna,
+		     const struct sna_copy_op *op,
+		     int16_t sx, int16_t sy,
+		     int16_t w,  int16_t h,
+		     int16_t dx, int16_t dy)
+{
+	int16_t *v;
+
+	gen9_get_rectangles(sna, &op->base, 1, gen9_emit_copy_state);
+
+	v = (int16_t *)&sna->render.vertices[sna->render.vertex_used];
+	sna->render.vertex_used += 6;
+	assert(sna->render.vertex_used <= sna->render.vertex_size);
+
+	v[0]  = dx+w; v[1]  = dy+h;
+	v[2]  = sx+w; v[3]  = sy+h;
+	v[4]  = dx;   v[5]  = dy+h;
+	v[6]  = sx;   v[7]  = sy+h;
+	v[8]  = dx;   v[9]  = dy;
+	v[10] = sx;   v[11] = sy;
+}
+
+static void
+gen9_render_copy_done(struct sna *sna, const struct sna_copy_op *op)
+{
+	if (sna->render.vertex_offset)
+		gen8_vertex_flush(sna);
+}
+
+static bool
+gen9_render_copy(struct sna *sna, uint8_t alu,
+		 PixmapPtr src, struct kgem_bo *src_bo,
+		 PixmapPtr dst, struct kgem_bo *dst_bo,
+		 struct sna_copy_op *op)
+{
+	DBG(("%s (alu=%d, src=(%dx%d), dst=(%dx%d))\n",
+	     __FUNCTION__, alu,
+	     src->drawable.width, src->drawable.height,
+	     dst->drawable.width, dst->drawable.height));
+
+	if (prefer_blt_copy(sna, src_bo, dst_bo, 0) &&
+	    sna_blt_compare_depth(&src->drawable, &dst->drawable) &&
+	    sna_blt_copy(sna, alu,
+			 src_bo, dst_bo,
+			 dst->drawable.bitsPerPixel,
+			 op))
+		return true;
+
+	if (!(alu == GXcopy || alu == GXclear) || src_bo == dst_bo ||
+	    too_large(src->drawable.width, src->drawable.height) ||
+	    too_large(dst->drawable.width, dst->drawable.height) ||
+	    unaligned(src_bo, src->drawable.bitsPerPixel) ||
+	    unaligned(dst_bo, dst->drawable.bitsPerPixel)) {
+fallback:
+		if (!sna_blt_compare_depth(&src->drawable, &dst->drawable))
+			return false;
+
+		return sna_blt_copy(sna, alu, src_bo, dst_bo,
+				    dst->drawable.bitsPerPixel,
+				    op);
+	}
+
+	if (dst->drawable.depth == src->drawable.depth) {
+		op->base.dst.format = sna_render_format_for_depth(dst->drawable.depth);
+		op->base.src.pict_format = op->base.dst.format;
+	} else {
+		op->base.dst.format = sna_format_for_depth(dst->drawable.depth);
+		op->base.src.pict_format = sna_format_for_depth(src->drawable.depth);
+	}
+	if (!gen9_check_format(op->base.src.pict_format))
+		goto fallback;
+
+	op->base.dst.pixmap = dst;
+	op->base.dst.width  = dst->drawable.width;
+	op->base.dst.height = dst->drawable.height;
+	op->base.dst.bo = dst_bo;
+
+	op->base.src.bo = src_bo;
+	op->base.src.card_format =
+		gen9_get_card_format(op->base.src.pict_format);
+	op->base.src.width  = src->drawable.width;
+	op->base.src.height = src->drawable.height;
+
+	op->base.mask.bo = NULL;
+
+	op->base.floats_per_vertex = 2;
+	op->base.floats_per_rect = 6;
+
+	op->base.u.gen9.flags = COPY_FLAGS(alu);
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, dst_bo);
+	if (!kgem_check_bo(&sna->kgem, dst_bo, src_bo, NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem, dst_bo, src_bo, NULL))
+			goto fallback;
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, &op->base);
+	gen9_emit_copy_state(sna, &op->base);
+
+	op->blt  = gen9_render_copy_blt;
+	op->done = gen9_render_copy_done;
+	return true;
+}
+
+static void
+gen9_emit_fill_state(struct sna *sna, const struct sna_composite_op *op)
+{
+	uint32_t *binding_table;
+	uint16_t offset, dirty;
+
+	/* XXX Render Target Fast Clear
+	 * Set RTFC Enable in PS and render a rectangle.
+	 * Limited to a clearing the full MSC surface only with a
+	 * specific kernel.
+	 */
+
+	gen9_get_batch(sna, op);
+
+	binding_table = gen9_composite_get_binding_table(sna, &offset);
+
+	dirty = kgem_bo_is_dirty(op->dst.bo);
+
+	binding_table[0] =
+		gen9_bind_bo(sna,
+			     op->dst.bo, op->dst.width, op->dst.height,
+			     gen9_get_dest_format(op->dst.format),
+			     true);
+	binding_table[1] =
+		gen9_bind_bo(sna,
+			     op->src.bo, 1, 1,
+			     SURFACEFORMAT_B8G8R8A8_UNORM,
+			     false);
+
+	if (sna->kgem.surface == offset &&
+	    *(uint64_t *)(sna->kgem.batch + sna->render_state.gen9.surface_table) == *(uint64_t*)binding_table) {
+		sna->kgem.surface += SURFACE_DW;
+		offset = sna->render_state.gen9.surface_table;
+	}
+
+	if (sna->kgem.batch[sna->render_state.gen9.surface_table] == binding_table[0])
+		dirty = 0;
+
+	gen9_emit_state(sna, op, offset | dirty);
+}
+
+static bool
+gen9_render_fill_boxes(struct sna *sna,
+		       CARD8 op,
+		       PictFormat format,
+		       const xRenderColor *color,
+		       const DrawableRec *dst, struct kgem_bo *dst_bo,
+		       const BoxRec *box, int n)
+{
+	struct sna_composite_op tmp;
+	uint32_t pixel;
+
+	DBG(("%s (op=%d, color=(%04x, %04x, %04x, %04x) [%08x])\n",
+	     __FUNCTION__, op,
+	     color->red, color->green, color->blue, color->alpha, (int)format));
+
+	if (op >= ARRAY_SIZE(gen9_blend_op)) {
+		DBG(("%s: fallback due to unhandled blend op: %d\n",
+		     __FUNCTION__, op));
+		return false;
+	}
+
+	if (prefer_blt_fill(sna, dst_bo, FILL_BOXES) ||
+	    !gen9_check_dst_format(format) ||
+	    unaligned(dst_bo, PICT_FORMAT_BPP(format))) {
+		uint8_t alu = GXinvalid;
+
+		if (op <= PictOpSrc) {
+			pixel = 0;
+			if (op == PictOpClear)
+				alu = GXclear;
+			else if (sna_get_pixel_from_rgba(&pixel,
+							 color->red,
+							 color->green,
+							 color->blue,
+							 color->alpha,
+							 format))
+				alu = GXcopy;
+		}
+
+		if (alu != GXinvalid &&
+		    sna_blt_fill_boxes(sna, alu,
+				       dst_bo, dst->bitsPerPixel,
+				       pixel, box, n))
+			return true;
+
+		if (!gen9_check_dst_format(format))
+			return false;
+	}
+
+	if (op == PictOpClear) {
+		pixel = 0;
+		op = PictOpSrc;
+	} else if (!sna_get_pixel_from_rgba(&pixel,
+					    color->red,
+					    color->green,
+					    color->blue,
+					    color->alpha,
+					    PICT_a8r8g8b8))
+		return false;
+
+	DBG(("%s(%08x x %d [(%d, %d), (%d, %d) ...])\n",
+	     __FUNCTION__, pixel, n,
+	     box[0].x1, box[0].y1, box[0].x2, box[0].y2));
+
+	tmp.dst.pixmap = (PixmapPtr)dst;
+	tmp.dst.width  = dst->width;
+	tmp.dst.height = dst->height;
+	tmp.dst.format = format;
+	tmp.dst.bo = dst_bo;
+	tmp.dst.x = tmp.dst.y = 0;
+	tmp.damage = NULL;
+
+	sna_render_composite_redirect_init(&tmp);
+	if (too_large(dst->width, dst->height)) {
+		BoxRec extents;
+
+		boxes_extents(box, n, &extents);
+		if (!sna_render_composite_redirect(sna, &tmp,
+						   extents.x1, extents.y1,
+						   extents.x2 - extents.x1,
+						   extents.y2 - extents.y1,
+						   n > 1))
+			return sna_tiling_fill_boxes(sna, op, format, color,
+						     dst, dst_bo, box, n);
+	}
+
+	tmp.src.bo = sna_render_get_solid(sna, pixel);
+	tmp.mask.bo = NULL;
+
+	tmp.floats_per_vertex = 2;
+	tmp.floats_per_rect = 6;
+	tmp.need_magic_ca_pass = false;
+
+	tmp.u.gen9.flags = FILL_FLAGS(op, format);
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, dst_bo);
+	if (!kgem_check_bo(&sna->kgem, dst_bo, NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem, dst_bo, NULL)) {
+			kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+			tmp.src.bo = NULL;
+
+			if (tmp.redirect.real_bo) {
+				kgem_bo_destroy(&sna->kgem, tmp.dst.bo);
+				tmp.redirect.real_bo = NULL;
+			}
+
+			return false;
+		}
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, &tmp);
+	gen9_emit_fill_state(sna, &tmp);
+
+	do {
+		int n_this_time;
+		int16_t *v;
+
+		n_this_time = gen9_get_rectangles(sna, &tmp, n,
+						  gen9_emit_fill_state);
+		n -= n_this_time;
+
+		v = (int16_t *)(sna->render.vertices + sna->render.vertex_used);
+		sna->render.vertex_used += 6 * n_this_time;
+		assert(sna->render.vertex_used <= sna->render.vertex_size);
+		do {
+			DBG(("	(%d, %d), (%d, %d)\n",
+			     box->x1, box->y1, box->x2, box->y2));
+
+			v[0] = box->x2;
+			v[5] = v[1] = box->y2;
+			v[8] = v[4] = box->x1;
+			v[9] = box->y1;
+			v[2] = v[3]  = v[7]  = 1;
+			v[6] = v[10] = v[11] = 0;
+			v += 12; box++;
+		} while (--n_this_time);
+	} while (n);
+
+	gen8_vertex_flush(sna);
+	kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+	sna_render_composite_redirect_done(sna, &tmp);
+	return true;
+}
+
+static void
+gen9_render_fill_op_blt(struct sna *sna,
+			const struct sna_fill_op *op,
+			int16_t x, int16_t y, int16_t w, int16_t h)
+{
+	int16_t *v;
+
+	DBG(("%s: (%d, %d)x(%d, %d)\n", __FUNCTION__, x, y, w, h));
+
+	gen9_get_rectangles(sna, &op->base, 1, gen9_emit_fill_state);
+
+	v = (int16_t *)&sna->render.vertices[sna->render.vertex_used];
+	sna->render.vertex_used += 6;
+	assert(sna->render.vertex_used <= sna->render.vertex_size);
+
+	v[0] = x+w;
+	v[4] = v[8] = x;
+	v[1] = v[5] = y+h;
+	v[9] = y;
+
+	v[2] = v[3]  = v[7]  = 1;
+	v[6] = v[10] = v[11] = 0;
+}
+
+fastcall static void
+gen9_render_fill_op_box(struct sna *sna,
+			const struct sna_fill_op *op,
+			const BoxRec *box)
+{
+	int16_t *v;
+
+	DBG(("%s: (%d, %d),(%d, %d)\n", __FUNCTION__,
+	     box->x1, box->y1, box->x2, box->y2));
+
+	gen9_get_rectangles(sna, &op->base, 1, gen9_emit_fill_state);
+
+	v = (int16_t *)&sna->render.vertices[sna->render.vertex_used];
+	sna->render.vertex_used += 6;
+	assert(sna->render.vertex_used <= sna->render.vertex_size);
+
+	v[0] = box->x2;
+	v[8] = v[4] = box->x1;
+	v[5] = v[1] = box->y2;
+	v[9] = box->y1;
+
+	v[7] = v[2]  = v[3]  = 1;
+	v[6] = v[10] = v[11] = 0;
+}
+
+fastcall static void
+gen9_render_fill_op_boxes(struct sna *sna,
+			  const struct sna_fill_op *op,
+			  const BoxRec *box,
+			  int nbox)
+{
+	DBG(("%s: (%d, %d),(%d, %d)... x %d\n", __FUNCTION__,
+	     box->x1, box->y1, box->x2, box->y2, nbox));
+
+	do {
+		int nbox_this_time;
+		int16_t *v;
+
+		nbox_this_time = gen9_get_rectangles(sna, &op->base, nbox,
+						     gen9_emit_fill_state);
+		nbox -= nbox_this_time;
+
+		v = (int16_t *)&sna->render.vertices[sna->render.vertex_used];
+		sna->render.vertex_used += 6 * nbox_this_time;
+		assert(sna->render.vertex_used <= sna->render.vertex_size);
+
+		do {
+			v[0] = box->x2;
+			v[8] = v[4] = box->x1;
+			v[5] = v[1] = box->y2;
+			v[9] = box->y1;
+			v[7] = v[2]  = v[3]  = 1;
+			v[6] = v[10] = v[11] = 0;
+			box++; v += 12;
+		} while (--nbox_this_time);
+	} while (nbox);
+}
+
+static void
+gen9_render_fill_op_done(struct sna *sna, const struct sna_fill_op *op)
+{
+	if (sna->render.vertex_offset)
+		gen8_vertex_flush(sna);
+	kgem_bo_destroy(&sna->kgem, op->base.src.bo);
+}
+
+static bool
+gen9_render_fill(struct sna *sna, uint8_t alu,
+		 PixmapPtr dst, struct kgem_bo *dst_bo,
+		 uint32_t color, unsigned flags,
+		 struct sna_fill_op *op)
+{
+	DBG(("%s: (alu=%d, color=%x)\n", __FUNCTION__, alu, color));
+
+	if (prefer_blt_fill(sna, dst_bo, flags) &&
+	    sna_blt_fill(sna, alu,
+			 dst_bo, dst->drawable.bitsPerPixel,
+			 color,
+			 op))
+		return true;
+
+	if (!(alu == GXcopy || alu == GXclear) ||
+	    too_large(dst->drawable.width, dst->drawable.height) ||
+	    unaligned(dst_bo, dst->drawable.bitsPerPixel))
+		return sna_blt_fill(sna, alu,
+				    dst_bo, dst->drawable.bitsPerPixel,
+				    color,
+				    op);
+
+	if (alu == GXclear)
+		color = 0;
+
+	op->base.dst.pixmap = dst;
+	op->base.dst.width  = dst->drawable.width;
+	op->base.dst.height = dst->drawable.height;
+	op->base.dst.format = sna_format_for_depth(dst->drawable.depth);
+	op->base.dst.bo = dst_bo;
+	op->base.dst.x = op->base.dst.y = 0;
+
+	op->base.src.bo =
+		sna_render_get_solid(sna,
+				     sna_rgba_for_color(color,
+							dst->drawable.depth));
+	op->base.mask.bo = NULL;
+
+	op->base.need_magic_ca_pass = false;
+	op->base.floats_per_vertex = 2;
+	op->base.floats_per_rect = 6;
+
+	op->base.u.gen9.flags = FILL_FLAGS_NOBLEND;
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, dst_bo);
+	if (!kgem_check_bo(&sna->kgem, dst_bo, NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem, dst_bo, NULL)) {
+			kgem_bo_destroy(&sna->kgem, op->base.src.bo);
+			return false;
+		}
+
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, &op->base);
+	gen9_emit_fill_state(sna, &op->base);
+
+	op->blt   = gen9_render_fill_op_blt;
+	op->box   = gen9_render_fill_op_box;
+	op->boxes = gen9_render_fill_op_boxes;
+	op->points = NULL;
+	op->done  = gen9_render_fill_op_done;
+	return true;
+}
+
+static bool
+gen9_render_fill_one_try_blt(struct sna *sna, PixmapPtr dst, struct kgem_bo *bo,
+			     uint32_t color,
+			     int16_t x1, int16_t y1, int16_t x2, int16_t y2,
+			     uint8_t alu)
+{
+	BoxRec box;
+
+	box.x1 = x1;
+	box.y1 = y1;
+	box.x2 = x2;
+	box.y2 = y2;
+
+	return sna_blt_fill_boxes(sna, alu,
+				  bo, dst->drawable.bitsPerPixel,
+				  color, &box, 1);
+}
+
+static bool
+gen9_render_fill_one(struct sna *sna, PixmapPtr dst, struct kgem_bo *bo,
+		     uint32_t color,
+		     int16_t x1, int16_t y1,
+		     int16_t x2, int16_t y2,
+		     uint8_t alu)
+{
+	struct sna_composite_op tmp;
+	int16_t *v;
+
+	/* Prefer to use the BLT if already engaged */
+	if (prefer_blt_fill(sna, bo, FILL_BOXES) &&
+	    gen9_render_fill_one_try_blt(sna, dst, bo, color,
+					 x1, y1, x2, y2, alu))
+		return true;
+
+	/* Must use the BLT if we can't RENDER... */
+	if (!(alu == GXcopy || alu == GXclear) ||
+	    too_large(dst->drawable.width, dst->drawable.height) ||
+	    unaligned(bo, dst->drawable.bitsPerPixel))
+		return gen9_render_fill_one_try_blt(sna, dst, bo, color,
+						    x1, y1, x2, y2, alu);
+
+	if (alu == GXclear)
+		color = 0;
+
+	tmp.dst.pixmap = dst;
+	tmp.dst.width  = dst->drawable.width;
+	tmp.dst.height = dst->drawable.height;
+	tmp.dst.format = sna_format_for_depth(dst->drawable.depth);
+	tmp.dst.bo = bo;
+	tmp.dst.x = tmp.dst.y = 0;
+
+	tmp.src.bo =
+		sna_render_get_solid(sna,
+				     sna_rgba_for_color(color,
+							dst->drawable.depth));
+	tmp.mask.bo = NULL;
+
+	tmp.floats_per_vertex = 2;
+	tmp.floats_per_rect = 6;
+	tmp.need_magic_ca_pass = false;
+
+	tmp.u.gen9.flags = FILL_FLAGS_NOBLEND;
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, bo);
+	if (!kgem_check_bo(&sna->kgem, bo, NULL)) {
+		kgem_submit(&sna->kgem);
+		if (kgem_check_bo(&sna->kgem, bo, NULL)) {
+			kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+			return false;
+		}
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, &tmp);
+	gen9_emit_fill_state(sna, &tmp);
+
+	gen9_get_rectangles(sna, &tmp, 1, gen9_emit_fill_state);
+
+	DBG(("	(%d, %d), (%d, %d)\n", x1, y1, x2, y2));
+
+	v = (int16_t *)&sna->render.vertices[sna->render.vertex_used];
+	sna->render.vertex_used += 6;
+	assert(sna->render.vertex_used <= sna->render.vertex_size);
+
+	v[0] = x2;
+	v[8] = v[4] = x1;
+	v[5] = v[1] = y2;
+	v[9] = y1;
+	v[7] = v[2]  = v[3]  = 1;
+	v[6] = v[10] = v[11] = 0;
+
+	gen8_vertex_flush(sna);
+	kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+
+	return true;
+}
+
+static bool
+gen9_render_clear_try_blt(struct sna *sna, PixmapPtr dst, struct kgem_bo *bo)
+{
+	BoxRec box;
+
+	box.x1 = 0;
+	box.y1 = 0;
+	box.x2 = dst->drawable.width;
+	box.y2 = dst->drawable.height;
+
+	return sna_blt_fill_boxes(sna, GXclear,
+				  bo, dst->drawable.bitsPerPixel,
+				  0, &box, 1);
+}
+
+static bool
+gen9_render_clear(struct sna *sna, PixmapPtr dst, struct kgem_bo *bo)
+{
+	struct sna_composite_op tmp;
+	int16_t *v;
+
+	DBG(("%s: %dx%d\n",
+	     __FUNCTION__,
+	     dst->drawable.width,
+	     dst->drawable.height));
+
+	/* Prefer to use the BLT if already engaged */
+	if (sna->kgem.mode == KGEM_BLT &&
+	    gen9_render_clear_try_blt(sna, dst, bo))
+		return true;
+
+	/* Must use the BLT if we can't RENDER... */
+	if (too_large(dst->drawable.width, dst->drawable.height) ||
+	    unaligned(bo, dst->drawable.bitsPerPixel))
+		return gen9_render_clear_try_blt(sna, dst, bo);
+
+	tmp.dst.pixmap = dst;
+	tmp.dst.width  = dst->drawable.width;
+	tmp.dst.height = dst->drawable.height;
+	tmp.dst.format = sna_format_for_depth(dst->drawable.depth);
+	tmp.dst.bo = bo;
+	tmp.dst.x = tmp.dst.y = 0;
+
+	tmp.src.bo = sna_render_get_solid(sna, 0);
+	tmp.mask.bo = NULL;
+
+	tmp.floats_per_vertex = 2;
+	tmp.floats_per_rect = 6;
+	tmp.need_magic_ca_pass = false;
+
+	tmp.u.gen9.flags = FILL_FLAGS_NOBLEND;
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, bo);
+	if (!kgem_check_bo(&sna->kgem, bo, NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem, bo, NULL)) {
+			kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+			return false;
+		}
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, &tmp);
+	gen9_emit_fill_state(sna, &tmp);
+
+	gen9_get_rectangles(sna, &tmp, 1, gen9_emit_fill_state);
+
+	v = (int16_t *)&sna->render.vertices[sna->render.vertex_used];
+	sna->render.vertex_used += 6;
+	assert(sna->render.vertex_used <= sna->render.vertex_size);
+
+	v[0] = dst->drawable.width;
+	v[5] = v[1] = dst->drawable.height;
+	v[8] = v[4] = 0;
+	v[9] = 0;
+
+	v[7] = v[2]  = v[3]  = 1;
+	v[6] = v[10] = v[11] = 0;
+
+	gen8_vertex_flush(sna);
+	kgem_bo_destroy(&sna->kgem, tmp.src.bo);
+
+	return true;
+}
+
+#if !NO_VIDEO
+static uint32_t gen9_bind_video_source(struct sna *sna,
+				       struct kgem_bo *bo,
+				       uint32_t delta,
+				       int width,
+				       int height,
+				       int pitch,
+				       uint32_t format)
+{
+	uint32_t *ss;
+	int offset;
+
+	offset = sna->kgem.surface -= SURFACE_DW;
+	ss = sna->kgem.batch + offset;
+	ss[0] = (SURFACE_2D << SURFACE_TYPE_SHIFT |
+		 gen9_tiling_bits(bo->tiling) |
+		 format << SURFACE_FORMAT_SHIFT |
+		 SURFACE_VALIGN_4 | SURFACE_HALIGN_4);
+	ss[1] = 0;
+	ss[2] = ((width - 1)  << SURFACE_WIDTH_SHIFT |
+		 (height - 1) << SURFACE_HEIGHT_SHIFT);
+	ss[3] = (pitch - 1) << SURFACE_PITCH_SHIFT;
+	ss[4] = 0;
+	ss[5] = 0;
+	ss[6] = 0;
+	ss[7] = SURFACE_SWIZZLE(RED, GREEN, BLUE, ALPHA);
+	*(uint64_t *)(ss+8) =
+		kgem_add_reloc64(&sna->kgem, offset + 8, bo,
+				 I915_GEM_DOMAIN_SAMPLER << 16,
+				 delta);
+	ss[10] = 0;
+	ss[11] = 0;
+	ss[12] = 0;
+	ss[13] = 0;
+	ss[14] = 0;
+	ss[15] = 0;
+
+	DBG(("[%x] bind bo(handle=%d, addr=%d), format=%d, width=%d, height=%d, pitch=%d, tiling=%d -> sampler\n",
+	     offset, bo->handle, ss[1],
+	     format, width, height, bo->pitch, bo->tiling));
+
+	return offset * sizeof(uint32_t);
+}
+
+static void gen9_emit_video_state(struct sna *sna,
+				  const struct sna_composite_op *op)
+{
+	struct sna_video_frame *frame = op->priv;
+	uint32_t src_surf_format;
+	uint32_t src_surf_base[6];
+	int src_width[6];
+	int src_height[6];
+	int src_pitch[6];
+	uint32_t *binding_table;
+	uint16_t offset;
+	int n_src, n;
+
+	/* XXX VeBox, bicubic */
+
+	gen9_get_batch(sna, op);
+
+	src_surf_base[0] = 0;
+	src_surf_base[1] = 0;
+	src_surf_base[2] = frame->VBufOffset;
+	src_surf_base[3] = frame->VBufOffset;
+	src_surf_base[4] = frame->UBufOffset;
+	src_surf_base[5] = frame->UBufOffset;
+
+	if (is_planar_fourcc(frame->id)) {
+		src_surf_format = SURFACEFORMAT_R8_UNORM;
+		src_width[1]  = src_width[0]  = frame->width;
+		src_height[1] = src_height[0] = frame->height;
+		src_pitch[1]  = src_pitch[0]  = frame->pitch[1];
+		src_width[4]  = src_width[5]  = src_width[2]  = src_width[3] =
+			frame->width / 2;
+		src_height[4] = src_height[5] = src_height[2] = src_height[3] =
+			frame->height / 2;
+		src_pitch[4]  = src_pitch[5]  = src_pitch[2]  = src_pitch[3] =
+			frame->pitch[0];
+		n_src = 6;
+	} else {
+		if (frame->id == FOURCC_RGB888)
+			src_surf_format = SURFACEFORMAT_B8G8R8X8_UNORM;
+		else if (frame->id == FOURCC_UYVY)
+			src_surf_format = SURFACEFORMAT_YCRCB_SWAPY;
+		else
+			src_surf_format = SURFACEFORMAT_YCRCB_NORMAL;
+
+		src_width[0]  = frame->width;
+		src_height[0] = frame->height;
+		src_pitch[0]  = frame->pitch[0];
+		n_src = 1;
+	}
+
+	binding_table = gen9_composite_get_binding_table(sna, &offset);
+
+	binding_table[0] =
+		gen9_bind_bo(sna,
+			     op->dst.bo, op->dst.width, op->dst.height,
+			     gen9_get_dest_format(op->dst.format),
+			     true);
+	for (n = 0; n < n_src; n++) {
+		binding_table[1+n] =
+			gen9_bind_video_source(sna,
+					       frame->bo,
+					       src_surf_base[n],
+					       src_width[n],
+					       src_height[n],
+					       src_pitch[n],
+					       src_surf_format);
+	}
+
+	gen9_emit_state(sna, op, offset);
+}
+
+static unsigned select_video_kernel(const struct sna_video_frame *frame)
+{
+	switch (frame->id) {
+	case FOURCC_YV12:
+	case FOURCC_I420:
+	case FOURCC_XVMC:
+		return GEN9_WM_KERNEL_VIDEO_PLANAR;
+
+	case FOURCC_RGB888:
+	case FOURCC_RGB565:
+		return GEN9_WM_KERNEL_VIDEO_RGB;
+
+	default:
+		return GEN9_WM_KERNEL_VIDEO_PACKED;
+	}
+}
+
+static bool
+gen9_render_video(struct sna *sna,
+		  struct sna_video *video,
+		  struct sna_video_frame *frame,
+		  RegionPtr dstRegion,
+		  PixmapPtr pixmap)
+{
+	struct sna_composite_op tmp;
+	struct sna_pixmap *priv = sna_pixmap(pixmap);
+	int dst_width = dstRegion->extents.x2 - dstRegion->extents.x1;
+	int dst_height = dstRegion->extents.y2 - dstRegion->extents.y1;
+	int src_width = frame->src.x2 - frame->src.x1;
+	int src_height = frame->src.y2 - frame->src.y1;
+	float src_offset_x, src_offset_y;
+	float src_scale_x, src_scale_y;
+	unsigned filter;
+	const BoxRec *box;
+	int nbox;
+
+	DBG(("%s: src=(%d, %d), dst=(%d, %d), %dx[(%d, %d), (%d, %d)...]\n",
+	     __FUNCTION__,
+	     src_width, src_height, dst_width, dst_height,
+	     region_num_rects(dstRegion),
+	     REGION_EXTENTS(NULL, dstRegion)->x1,
+	     REGION_EXTENTS(NULL, dstRegion)->y1,
+	     REGION_EXTENTS(NULL, dstRegion)->x2,
+	     REGION_EXTENTS(NULL, dstRegion)->y2));
+
+	assert(priv->gpu_bo);
+	assert(!too_large(pixmap->drawable.width, pixmap->drawable.height));
+	assert(!unaligned(priv->gpu_bo, pixmap->drawable.bitsPerPixel));
+
+	memset(&tmp, 0, sizeof(tmp));
+
+	tmp.dst.pixmap = pixmap;
+	tmp.dst.width  = pixmap->drawable.width;
+	tmp.dst.height = pixmap->drawable.height;
+	tmp.dst.format = sna_render_format_for_depth(pixmap->drawable.depth);
+	tmp.dst.bo = priv->gpu_bo;
+
+	tmp.src.bo = frame->bo;
+	tmp.mask.bo = NULL;
+
+	tmp.floats_per_vertex = 3;
+	tmp.floats_per_rect = 9;
+
+	DBG(("%s: scaling?=%d, planar?=%d [%x]\n",
+	     __FUNCTION__,
+	     src_width != dst_width || src_height != dst_height,
+	     is_planar_fourcc(frame->id), frame->id));
+
+	if (src_width == dst_width && src_height == dst_height)
+		filter = SAMPLER_FILTER_NEAREST;
+	else
+		filter = SAMPLER_FILTER_BILINEAR;
+
+	tmp.u.gen9.flags =
+		GEN9_SET_FLAGS(SAMPLER_OFFSET(filter, SAMPLER_EXTEND_PAD,
+					      SAMPLER_FILTER_NEAREST, SAMPLER_EXTEND_NONE),
+			       NO_BLEND,
+			       select_video_kernel(frame),
+			       2);
+	tmp.priv = frame;
+
+	kgem_set_mode(&sna->kgem, KGEM_RENDER, tmp.dst.bo);
+	if (!kgem_check_bo(&sna->kgem, tmp.dst.bo, frame->bo, NULL)) {
+		kgem_submit(&sna->kgem);
+		if (!kgem_check_bo(&sna->kgem, tmp.dst.bo, frame->bo, NULL))
+			return false;
+
+		_kgem_set_mode(&sna->kgem, KGEM_RENDER);
+	}
+
+	gen9_align_vertex(sna, &tmp);
+	gen9_emit_video_state(sna, &tmp);
+
+	DBG(("%s: src=(%d, %d)x(%d, %d); frame=(%dx%d), dst=(%dx%d)\n",
+	     __FUNCTION__,
+	     frame->src.x1, frame->src.y1,
+	     src_width, src_height,
+	     dst_width, dst_height,
+	     frame->width, frame->height));
+
+	src_scale_x = (float)src_width / dst_width / frame->width;
+	src_offset_x = (float)frame->src.x1 / frame->width - dstRegion->extents.x1 * src_scale_x;
+
+	src_scale_y = (float)src_height / dst_height / frame->height;
+	src_offset_y = (float)frame->src.y1 / frame->height - dstRegion->extents.y1 * src_scale_y;
+
+	DBG(("%s: scale=(%f, %f), offset=(%f, %f)\n",
+	     __FUNCTION__,
+	     src_scale_x, src_scale_y,
+	     src_offset_x, src_offset_y));
+
+	box = region_rects(dstRegion);
+	nbox = region_num_rects(dstRegion);
+	while (nbox--) {
+		DBG(("%s: dst=(%d, %d), (%d, %d) + (%d, %d); src=(%f, %f), (%f, %f)\n",
+		     __FUNCTION__,
+		     box->x1, box->y1,
+		     box->x2, box->y2,
+		     box->x1 * src_scale_x + src_offset_x,
+		     box->y1 * src_scale_y + src_offset_y,
+		     box->x2 * src_scale_x + src_offset_x,
+		     box->y2 * src_scale_y + src_offset_y));
+
+		gen9_get_rectangles(sna, &tmp, 1, gen9_emit_video_state);
+
+		OUT_VERTEX(box->x2, box->y2);
+		OUT_VERTEX_F(box->x2 * src_scale_x + src_offset_x);
+		OUT_VERTEX_F(box->y2 * src_scale_y + src_offset_y);
+
+		OUT_VERTEX(box->x1, box->y2);
+		OUT_VERTEX_F(box->x1 * src_scale_x + src_offset_x);
+		OUT_VERTEX_F(box->y2 * src_scale_y + src_offset_y);
+
+		OUT_VERTEX(box->x1, box->y1);
+		OUT_VERTEX_F(box->x1 * src_scale_x + src_offset_x);
+		OUT_VERTEX_F(box->y1 * src_scale_y + src_offset_y);
+
+		box++;
+	}
+	gen8_vertex_flush(sna);
+
+	if (!DAMAGE_IS_ALL(priv->gpu_damage))
+		sna_damage_add(&priv->gpu_damage, dstRegion);
+
+	return true;
+}
+#endif
+
+static void gen9_render_flush(struct sna *sna)
+{
+	gen8_vertex_close(sna);
+
+	assert(sna->render.vb_id == 0);
+	assert(sna->render.vertex_offset == 0);
+}
+
+static void gen9_render_reset(struct sna *sna)
+{
+	sna->render_state.gen9.emit_flush = false;
+	sna->render_state.gen9.needs_invariant = true;
+	sna->render_state.gen9.ve_id = 3 << 2;
+	sna->render_state.gen9.last_primitive = -1;
+
+	sna->render_state.gen9.num_sf_outputs = 0;
+	sna->render_state.gen9.samplers = -1;
+	sna->render_state.gen9.blend = -1;
+	sna->render_state.gen9.kernel = -1;
+	sna->render_state.gen9.drawrect_offset = -1;
+	sna->render_state.gen9.drawrect_limit = -1;
+	sna->render_state.gen9.surface_table = 0;
+
+	if (sna->render.vbo && !kgem_bo_can_map(&sna->kgem, sna->render.vbo)) {
+		DBG(("%s: discarding unmappable vbo\n", __FUNCTION__));
+		discard_vbo(sna);
+	}
+
+	sna->render.vertex_offset = 0;
+	sna->render.nvertex_reloc = 0;
+	sna->render.vb_id = 0;
+}
+
+static void gen9_render_fini(struct sna *sna)
+{
+	kgem_bo_destroy(&sna->kgem, sna->render_state.gen9.general_bo);
+}
+
+static bool gen9_render_setup(struct sna *sna)
+{
+	struct gen9_render_state *state = &sna->render_state.gen9;
+	struct sna_static_stream general;
+	struct gen9_sampler_state *ss;
+	int i, j, k, l, m;
+	uint32_t devid;
+
+	devid = intel_get_device_id(sna->dev);
+	if (devid & 0xf)
+		state->gt = ((devid >> 4) & 0xf) + 1;
+	DBG(("%s: gt=%d\n", __FUNCTION__, state->gt));
+
+	state->info = &skl_gt_info;
+	if (is_skl(sna))
+		state->info = &skl_gt_info;
+	else
+		return false;
+
+	sna_static_stream_init(&general);
+
+	/* Zero pad the start. If you see an offset of 0x0 in the batchbuffer
+	 * dumps, you know it points to zero.
+	 */
+	null_create(&general);
+
+	for (m = 0; m < ARRAY_SIZE(wm_kernels); m++) {
+		if (wm_kernels[m].size) {
+			state->wm_kernel[m][1] =
+				sna_static_stream_add(&general,
+						      wm_kernels[m].data,
+						      wm_kernels[m].size,
+						      64);
+		} else {
+			if (USE_8_PIXEL_DISPATCH) {
+				state->wm_kernel[m][0] =
+					sna_static_stream_compile_wm(sna, &general,
+								     wm_kernels[m].data, 8);
+			}
+
+			if (USE_16_PIXEL_DISPATCH) {
+				state->wm_kernel[m][1] =
+					sna_static_stream_compile_wm(sna, &general,
+								     wm_kernels[m].data, 16);
+			}
+
+			if (USE_32_PIXEL_DISPATCH) {
+				state->wm_kernel[m][2] =
+					sna_static_stream_compile_wm(sna, &general,
+								     wm_kernels[m].data, 32);
+			}
+		}
+		assert(state->wm_kernel[m][0]|state->wm_kernel[m][1]|state->wm_kernel[m][2]);
+	}
+
+	COMPILE_TIME_ASSERT(SAMPLER_OFFSET(FILTER_COUNT, EXTEND_COUNT, FILTER_COUNT, EXTEND_COUNT) <= 0x7ff);
+	ss = sna_static_stream_map(&general,
+				   2 * sizeof(*ss) *
+				   (2 +
+				    FILTER_COUNT * EXTEND_COUNT *
+				    FILTER_COUNT * EXTEND_COUNT),
+				   32);
+	state->wm_state = sna_static_stream_offsetof(&general, ss);
+	sampler_copy_init(ss); ss += 2;
+	sampler_fill_init(ss); ss += 2;
+	for (i = 0; i < FILTER_COUNT; i++) {
+		for (j = 0; j < EXTEND_COUNT; j++) {
+			for (k = 0; k < FILTER_COUNT; k++) {
+				for (l = 0; l < EXTEND_COUNT; l++) {
+					sampler_state_init(ss++, i, j);
+					sampler_state_init(ss++, k, l);
+				}
+			}
+		}
+	}
+
+	state->cc_blend = gen9_create_blend_state(&general);
+
+	state->general_bo = sna_static_stream_fini(sna, &general);
+	return state->general_bo != NULL;
+}
+
+const char *gen9_render_init(struct sna *sna, const char *backend)
+{
+	if (!gen9_render_setup(sna))
+		return backend;
+
+	sna->kgem.context_switch = gen6_render_context_switch;
+	sna->kgem.retire = gen6_render_retire;
+	sna->kgem.expire = gen4_render_expire;
+
+#if !NO_COMPOSITE
+	sna->render.composite = gen9_render_composite;
+	sna->render.prefer_gpu |= PREFER_GPU_RENDER;
+#endif
+#if !NO_COMPOSITE_SPANS
+	sna->render.check_composite_spans = gen9_check_composite_spans;
+	sna->render.composite_spans = gen9_render_composite_spans;
+	sna->render.prefer_gpu |= PREFER_GPU_SPANS;
+#endif
+#if !NO_VIDEO
+	sna->render.video = gen9_render_video;
+#endif
+
+#if !NO_COPY_BOXES
+	sna->render.copy_boxes = gen9_render_copy_boxes;
+#endif
+#if !NO_COPY
+	sna->render.copy = gen9_render_copy;
+#endif
+
+#if !NO_FILL_BOXES
+	sna->render.fill_boxes = gen9_render_fill_boxes;
+#endif
+#if !NO_FILL
+	sna->render.fill = gen9_render_fill;
+#endif
+#if !NO_FILL_ONE
+	sna->render.fill_one = gen9_render_fill_one;
+#endif
+#if !NO_FILL_CLEAR
+	sna->render.clear = gen9_render_clear;
+#endif
+
+	sna->render.flush = gen9_render_flush;
+	sna->render.reset = gen9_render_reset;
+	sna->render.fini = gen9_render_fini;
+
+	sna->render.max_3d_size = GEN9_MAX_SIZE;
+	sna->render.max_3d_pitch = 1 << 18;
+	return sna->render_state.gen9.info->name;
+}
diff --git a/src/sna/gen9_render.h b/src/sna/gen9_render.h
new file mode 100644
index 0000000..e8fafb5
--- /dev/null
+++ b/src/sna/gen9_render.h
@@ -0,0 +1,1129 @@
+#ifndef GEN9_RENDER_H
+#define GEN9_RENDER_H
+
+#define INTEL_MASK(high, low) (((1 << ((high) - (low) + 1)) - 1) << (low))
+
+#define GEN9_3D(pipeline,op,sub) \
+	((3 << 29) | ((pipeline) << 27) | ((op) << 24) | ((sub) << 16))
+
+#define GEN9_STATE_BASE_ADDRESS			GEN9_3D(0, 1, 1)
+# define BASE_ADDRESS_MODIFY			(1 << 0)
+
+#define GEN9_STATE_SIP				GEN9_3D(0, 1, 2)
+
+#define GEN9_3DSTATE_VF_STATISTICS		GEN9_3D(1, 0, 0xb)
+#define GEN9_PIPELINE_SELECT			GEN9_3D(1, 1, 4)
+# define PIPELINE_SELECT_3D		0
+# define PIPELINE_SELECT_MEDIA		1
+#define PIPELINE_SELECTION_MASK            (3 << 8)
+
+#define GEN9_MEDIA_STATE_POINTERS		GEN9_3D(2, 0, 0)
+#define GEN9_MEDIA_OBJECT			GEN9_3D(2, 1, 0)
+
+#define GEN9_3DSTATE_CLEAR_PARAMS               GEN9_3D(3, 0, 0x04)
+#define GEN9_3DSTATE_DEPTH_BUFFER               GEN9_3D(3, 0, 0x05)
+# define DEPTH_BUFFER_TYPE_SHIFT	29
+# define DEPTH_BUFFER_FORMAT_SHIFT	18
+
+#define GEN9_3DSTATE_STENCIL_BUFFER		GEN9_3D(3, 0, 0x06)
+#define GEN9_3DSTATE_HIER_DEPTH_BUFFER		GEN9_3D(3, 0, 0x07)
+#define GEN9_3DSTATE_VERTEX_BUFFERS		GEN9_3D(3, 0, 0x08)
+# define VB_INDEX_SHIFT			26
+# define VB_MODIFY_ENABLE		(1 << 14)
+#define GEN9_3DSTATE_VERTEX_ELEMENTS		GEN9_3D(3, 0, 0x09)
+# define VE_INDEX_SHIFT		26
+# define VE_VALID					(1 << 25)
+# define VE_FORMAT_SHIFT				16
+# define VE_OFFSET_SHIFT				0
+# define VE_COMPONENT_0_SHIFT			28
+# define VE_COMPONENT_1_SHIFT			24
+# define VE_COMPONENT_2_SHIFT			20
+# define VE_COMPONENT_3_SHIFT			16
+#define GEN9_3DSTATE_INDEX_BUFFER		GEN9_3D(3, 0, 0x0a)
+#define GEN9_3DSTATE_VF				GEN9_3D(3, 0, 0x0c)
+
+#define GEN9_3DSTATE_MULTISAMPLE		GEN9_3D(3, 0, 0x0d)
+/* DW1 */
+# define MULTISAMPLE_PIXEL_LOCATION_CENTER		(0 << 4)
+# define MULTISAMPLE_PIXEL_LOCATION_UPPER_LEFT	(1 << 4)
+# define MULTISAMPLE_NUMSAMPLES_1			(0 << 1)
+# define MULTISAMPLE_NUMSAMPLES_4			(2 << 1)
+# define MULTISAMPLE_NUMSAMPLES_8			(3 << 1)
+
+#define GEN9_3DSTATE_CC_STATE_POINTERS		GEN9_3D(3, 0, 0x0e)
+#define GEN9_3DSTATE_SCISSOR_STATE_POINTERS	GEN9_3D(3, 0, 0x0f)
+
+#define GEN9_3DSTATE_VS				GEN9_3D(3, 0, 0x10)
+#define GEN9_3DSTATE_GS				GEN9_3D(3, 0, 0x11)
+#define GEN9_3DSTATE_CLIP			GEN9_3D(3, 0, 0x12)
+#define GEN9_3DSTATE_SF				GEN9_3D(3, 0, 0x13)
+# define SF_TRI_PROVOKE_SHIFT		29
+# define SF_LINE_PROVOKE_SHIFT		27
+# define SF_FAN_PROVOKE_SHIFT		25
+
+#define GEN9_3DSTATE_WM				GEN9_3D(3, 0, 0x14)
+/* DW1 */
+# define WM_STATISTICS_ENABLE                              (1 << 31)
+# define WM_DEPTH_CLEAR                                    (1 << 30)
+# define WM_DEPTH_RESOLVE                                  (1 << 28)
+# define WM_HIERARCHICAL_DEPTH_RESOLVE                     (1 << 27)
+# define WM_KILL_ENABLE                                    (1 << 25)
+# define WM_POSITION_ZW_PIXEL                              (0 << 17)
+# define WM_POSITION_ZW_CENTROID                           (2 << 17)
+# define WM_POSITION_ZW_SAMPLE                             (3 << 17)
+# define WM_NONPERSPECTIVE_SAMPLE_BARYCENTRIC              (1 << 16)
+# define WM_NONPERSPECTIVE_CENTROID_BARYCENTRIC            (1 << 15)
+# define WM_NONPERSPECTIVE_PIXEL_BARYCENTRIC               (1 << 14)
+# define WM_PERSPECTIVE_SAMPLE_BARYCENTRIC                 (1 << 13)
+# define WM_PERSPECTIVE_CENTROID_BARYCENTRIC               (1 << 12)
+# define WM_PERSPECTIVE_PIXEL_BARYCENTRIC                  (1 << 11)
+# define WM_LINE_END_CAP_AA_WIDTH_0_5                      (0 << 8)
+# define WM_LINE_END_CAP_AA_WIDTH_1_0                      (1 << 8)
+# define WM_LINE_END_CAP_AA_WIDTH_2_0                      (2 << 8)
+# define WM_LINE_END_CAP_AA_WIDTH_4_0                      (3 << 8)
+# define WM_LINE_AA_WIDTH_0_5                              (0 << 6)
+# define WM_LINE_AA_WIDTH_1_0                              (1 << 6)
+# define WM_LINE_AA_WIDTH_2_0                              (2 << 6)
+# define WM_LINE_AA_WIDTH_4_0                              (3 << 6)
+# define WM_POLYGON_STIPPLE_ENABLE                         (1 << 4)
+# define WM_LINE_STIPPLE_ENABLE                            (1 << 3)
+# define WM_POINT_RASTRULE_UPPER_RIGHT                     (1 << 2)
+# define WM_MSRAST_OFF_PIXEL                               (0 << 0)
+# define WM_MSRAST_OFF_PATTERN                             (1 << 0)
+# define WM_MSRAST_ON_PIXEL                                (2 << 0)
+# define WM_MSRAST_ON_PATTERN                              (3 << 0)
+
+#define GEN9_3DSTATE_CONSTANT_VS		GEN9_3D(3, 0, 0x15)
+#define GEN9_3DSTATE_CONSTANT_GS		GEN9_3D(3, 0, 0x16)
+#define GEN9_3DSTATE_CONSTANT_PS		GEN9_3D(3, 0, 0x17)
+
+#define GEN9_3DSTATE_SAMPLE_MASK		GEN9_3D(3, 0, 0x18)
+
+#define GEN9_3DSTATE_CONSTANT_HS                GEN9_3D(3, 0, 0x19)
+#define GEN9_3DSTATE_CONSTANT_DS                GEN9_3D(3, 0, 0x1a)
+
+#define GEN9_3DSTATE_HS                         GEN9_3D(3, 0, 0x1b)
+#define GEN9_3DSTATE_TE                         GEN9_3D(3, 0, 0x1c)
+#define GEN9_3DSTATE_DS                         GEN9_3D(3, 0, 0x1d)
+#define GEN9_3DSTATE_STREAMOUT                  GEN9_3D(3, 0, 0x1e)
+
+#define GEN9_3DSTATE_SBE                        GEN9_3D(3, 0, 0x1f)
+/* DW1 */
+# define SBE_FORCE_VERTEX_URB_READ_LENGTH  (1<<29)
+# define SBE_FORCE_VERTEX_URB_READ_OFFSET  (1<<28)
+# define SBE_NUM_OUTPUTS_SHIFT             22
+# define SBE_SWIZZLE_ENABLE                (1 << 21)
+# define SBE_POINT_SPRITE_LOWERLEFT        (1 << 20)
+# define SBE_URB_ENTRY_READ_LENGTH_SHIFT   11
+# define SBE_URB_ENTRY_READ_OFFSET_SHIFT   5
+#define SBE_ACTIVE_COMPONENT_NONE          0
+#define SBE_ACTIVE_COMPONENT_XY            1 
+#define SBE_ACTIVE_COMPONENT_XYZ           2
+#define SBE_ACTIVE_COMPONENT_XYZW          3
+
+
+#define GEN9_3DSTATE_PS                                 GEN9_3D(3, 0, 0x20)
+/* DW1:DW2 kernel pointer */
+/* DW3 */
+# define PS_SPF_MODE                               (1 << 31)
+# define PS_VECTOR_MASK_ENABLE                     (1 << 30)
+# define PS_SAMPLER_COUNT_SHIFT                    27
+# define PS_BINDING_TABLE_ENTRY_COUNT_SHIFT        18
+# define PS_FLOATING_POINT_MODE_IEEE_754           (0 << 16)
+# define PS_FLOATING_POINT_MODE_ALT                (1 << 16)
+/* DW4:DW5: scratch space */
+/* DW6 */
+# define PS_MAX_THREADS_SHIFT                      23
+# define PS_MAX_THREADS                            (63 << PS_MAX_THREADS_SHIFT)
+# define PS_PUSH_CONSTANT_ENABLE                   (1 << 11)
+# define PS_RENDER_TARGET_CLEAR			   (1 << 8)
+# define PS_RENDER_TARGET_RESOLVE		   (1 << 6)
+# define PS_POSOFFSET_NONE                         (0 << 3)
+# define PS_POSOFFSET_CENTROID                     (2 << 3)
+# define PS_POSOFFSET_SAMPLE                       (3 << 3)
+# define PS_32_DISPATCH_ENABLE                     (1 << 2)
+# define PS_16_DISPATCH_ENABLE                     (1 << 1)
+# define PS_8_DISPATCH_ENABLE                      (1 << 0)
+/* DW7 */
+# define PS_DISPATCH_START_GRF_SHIFT_0             16
+# define PS_DISPATCH_START_GRF_SHIFT_1             8
+# define PS_DISPATCH_START_GRF_SHIFT_2             0
+/* DW8:D9: kernel 1 pointer */
+/* DW10:D11: kernel 2 pointer */
+
+#define GEN9_3DSTATE_VIEWPORT_STATE_POINTERS_SF_CLIP      GEN9_3D(3, 0, 0x21)
+#define GEN9_3DSTATE_VIEWPORT_STATE_POINTERS_CC         GEN9_3D(3, 0, 0x23)
+
+#define GEN9_3DSTATE_BLEND_STATE_POINTERS               GEN9_3D(3, 0, 0x24)
+
+#define GEN9_3DSTATE_BINDING_TABLE_POINTERS_VS          GEN9_3D(3, 0, 0x26)
+#define GEN9_3DSTATE_BINDING_TABLE_POINTERS_HS          GEN9_3D(3, 0, 0x27)
+#define GEN9_3DSTATE_BINDING_TABLE_POINTERS_DS          GEN9_3D(3, 0, 0x28)
+#define GEN9_3DSTATE_BINDING_TABLE_POINTERS_GS          GEN9_3D(3, 0, 0x29)
+#define GEN9_3DSTATE_BINDING_TABLE_POINTERS_PS          GEN9_3D(3, 0, 0x2a)
+
+#define GEN9_3DSTATE_SAMPLER_STATE_POINTERS_VS          GEN9_3D(3, 0, 0x2b)
+#define GEN9_3DSTATE_SAMPLER_STATE_POINTERS_HS          GEN9_3D(3, 0, 0x2c)
+#define GEN9_3DSTATE_SAMPLER_STATE_POINTERS_DS          GEN9_3D(3, 0, 0x2d)
+#define GEN9_3DSTATE_SAMPLER_STATE_POINTERS_GS          GEN9_3D(3, 0, 0x2e)
+#define GEN9_3DSTATE_SAMPLER_STATE_POINTERS_PS          GEN9_3D(3, 0, 0x2f)
+
+#define GEN9_3DSTATE_URB_VS                             GEN9_3D(3, 0, 0x30)
+#define GEN9_3DSTATE_URB_HS                             GEN9_3D(3, 0, 0x31)
+#define GEN9_3DSTATE_URB_DS                             GEN9_3D(3, 0, 0x32)
+#define GEN9_3DSTATE_URB_GS                             GEN9_3D(3, 0, 0x33)
+/* DW1 */
+# define URB_ENTRY_NUMBER_SHIFT            0
+# define URB_ENTRY_SIZE_SHIFT              16
+# define URB_STARTING_ADDRESS_SHIFT        25
+
+#define GEN9_3DSTATE_GATHER_CONSTANT_VS             GEN9_3D(3, 0, 0x34)
+#define GEN9_3DSTATE_GATHER_CONSTANT_GS             GEN9_3D(3, 0, 0x35)
+#define GEN9_3DSTATE_GATHER_CONSTANT_HS             GEN9_3D(3, 0, 0x36)
+#define GEN9_3DSTATE_GATHER_CONSTANT_DS             GEN9_3D(3, 0, 0x37)
+#define GEN9_3DSTATE_GATHER_CONSTANT_PS             GEN9_3D(3, 0, 0x38)
+
+#define GEN9_3DSTATE_DX9_CONSTANTF_VS             GEN9_3D(3, 0, 0x39)
+#define GEN9_3DSTATE_DX9_CONSTANTF_PS             GEN9_3D(3, 0, 0x3a)
+#define GEN9_3DSTATE_DX9_CONSTANTI_VS             GEN9_3D(3, 0, 0x3b)
+#define GEN9_3DSTATE_DX9_CONSTANTI_PS             GEN9_3D(3, 0, 0x3c)
+#define GEN9_3DSTATE_DX9_CONSTANTB_VS             GEN9_3D(3, 0, 0x3d)
+#define GEN9_3DSTATE_DX9_CONSTANTB_PS             GEN9_3D(3, 0, 0x3e)
+#define GEN9_3DSTATE_DX9_LOCAL_VALID_VS           GEN9_3D(3, 0, 0x3f)
+#define GEN9_3DSTATE_DX9_LOCAL_VALID_PS           GEN9_3D(3, 0, 0x40)
+#define GEN9_3DSTATE_DX9_GENERATE_ACTIVE_VS       GEN9_3D(3, 0, 0x41)
+#define GEN9_3DSTATE_DX9_GENERATE_ACTIVE_PS       GEN9_3D(3, 0, 0x42)
+
+#define GEN9_3DSTATE_BINDING_TABLE_EDIT_VS       GEN9_3D(3, 0, 0x43)
+#define GEN9_3DSTATE_BINDING_TABLE_EDIT_GS       GEN9_3D(3, 0, 0x44)
+#define GEN9_3DSTATE_BINDING_TABLE_EDIT_HS       GEN9_3D(3, 0, 0x45)
+#define GEN9_3DSTATE_BINDING_TABLE_EDIT_DS       GEN9_3D(3, 0, 0x46)
+#define GEN9_3DSTATE_BINDING_TABLE_EDIT_PS       GEN9_3D(3, 0, 0x47)
+
+#define GEN9_3DSTATE_VF_INSTANCING		GEN9_3D(3, 0, 0x49)
+#define GEN9_3DSTATE_VF_SGVS			GEN9_3D(3, 0, 0x4a)
+# define SGVS_ENABLE_INSTANCE_ID			(1 << 31)
+# define SGVS_INSTANCE_ID_COMPONENT_SHIFT		29
+# define SGVS_INSTANCE_ID_ELEMENT_OFFSET_SHIFT	16
+# define SGVS_ENABLE_VERTEX_ID			(1 << 15)
+# define SGVS_VERTEX_ID_COMPONENT_SHIFT            13
+# define SGVS_VERTEX_ID_ELEMENT_OFFSET_SHIFT	0
+#define GEN9_3DSTATE_VF_TOPOLOGY		GEN9_3D(3, 0, 0x4b)
+# define POINTLIST         0x01
+# define LINELIST          0x02
+# define LINESTRIP         0x03
+# define TRILIST           0x04
+# define TRISTRIP          0x05
+# define TRIFAN            0x06
+# define QUADLIST          0x07
+# define QUADSTRIP         0x08
+# define LINELIST_ADJ      0x09
+# define LINESTRIP_ADJ     0x0A
+# define TRILIST_ADJ       0x0B
+# define TRISTRIP_ADJ      0x0C
+# define TRISTRIP_REVERSE  0x0D
+# define POLYGON           0x0E
+# define RECTLIST          0x0F
+# define LINELOOP          0x10
+# define POINTLIST_BF      0x11
+# define LINESTRIP_CONT    0x12
+# define LINESTRIP_BF      0x13
+# define LINESTRIP_CONT_BF 0x14
+# define TRIFAN_NOSTIPPLE  0x15
+
+#define GEN9_3DSTATE_WM_CHROMAKEY		GEN9_3D(3, 0, 0x4c)
+
+#define GEN9_3DSTATE_PS_BLEND				GEN9_3D(3, 0, 0x4d)
+# define PS_BLEND_ALPHA_TO_COVERAGE_ENABLE		(1 << 31)
+# define PS_BLEND_HAS_WRITEABLE_RT			(1 << 30)
+# define PS_BLEND_COLOR_BLEND_ENABLE			(1 << 29)
+# define PS_BLEND_SRC_ALPHA_SHIFT			24
+# define PS_BLEND_DST_ALPHA_SHIFT			19
+# define PS_BLEND_SRC_SHIFT				14
+# define PS_BLEND_DST_SHIFT				9
+# define PS_BLEND_ALPHA_TEST_ENABLE			(1 << 8)
+# define PS_BLEND_INDEPENDENT_ALPHA_BLEND_ENABLE	(1 << 7)
+
+#define GEN9_3DSTATE_WM_DEPTH_STENCIL		GEN9_3D(3, 0, 0x4e)
+/* DW1 */
+# define WM_DS_STENCIL_TEST_MASK_MASK		INTEL_MASK(31, 24)
+# define WM_DS_STENCIL_TEST_MASK_SHIFT		24
+# define WM_DS_STENCIL_WRITE_MASK_MASK		INTEL_MASK(23, 16)
+# define WM_DS_STENCIL_WRITE_MASK_SHIFT		16
+# define WM_DS_BF_STENCIL_TEST_MASK_MASK		INTEL_MASK(15, 8)
+# define WM_DS_BF_STENCIL_TEST_MASK_SHIFT		8
+# define WM_DS_BF_STENCIL_WRITE_MASK_MASK		INTEL_MASK(7, 0)
+# define WM_DS_DEPTH_FUNC_SHIFT			5
+# define WM_DS_DOUBLE_SIDED_STENCIL_ENABLE		(1 << 4)
+# define WM_DS_STENCIL_TEST_ENABLE			(1 << 3)
+# define WM_DS_STENCIL_BUFFER_WRITE_ENABLE		(1 << 2)
+# define WM_DS_DEPTH_TEST_ENABLE			(1 << 1)
+# define WM_DS_DEPTH_BUFFER_WRITE_ENABLE		(1 << 0)
+/* DW2 */
+# define WM_DS_STENCIL_TEST_MASK_MASK		INTEL_MASK(31, 24)
+# define WM_DS_STENCIL_TEST_MASK_SHIFT		24
+# define WM_DS_STENCIL_WRITE_MASK_MASK		INTEL_MASK(23, 16)
+# define WM_DS_STENCIL_WRITE_MASK_SHIFT		16
+# define WM_DS_BF_STENCIL_TEST_MASK_MASK		INTEL_MASK(15, 8)
+# define WM_DS_BF_STENCIL_TEST_MASK_SHIFT		8
+# define WM_DS_BF_STENCIL_WRITE_MASK_MASK		INTEL_MASK(7, 0)
+# define WM_DS_BF_STENCIL_WRITE_MASK_SHIFT		0
+
+#define GEN9_3DSTATE_PS_EXTRA		GEN9_3D(3, 0, 0x4f)
+# define PSX_PIXEL_SHADER_VALID                    (1 << 31)
+# define PSX_PIXEL_SHADER_NO_RT_WRITE              (1 << 30)
+# define PSX_OMASK_TO_RENDER_TARGET                (1 << 29)
+# define PSX_KILL_ENABLE                           (1 << 28)
+# define PSX_PSCDEPTH_OFF                          (0 << 26)
+# define PSX_PSCDEPTH_ON                           (1 << 26)
+# define PSX_PSCDEPTH_ON_GE                        (2 << 26)
+# define PSX_PSCDEPTH_ON_LE                        (3 << 26)
+# define PSX_FORCE_COMPUTED_DEPTH                  (1 << 25)
+# define PSX_USES_SOURCE_DEPTH                     (1 << 24)
+# define PSX_USES_SOURCE_W                         (1 << 23)
+# define PSX_ATTRIBUTE_ENABLE                      (1 << 8)
+# define PSX_SHADER_DISABLES_ALPHA_TO_COVERAGE     (1 << 7)
+# define PSX_SHADER_IS_PER_SAMPLE                  (1 << 6)
+# define PSX_SHADER_HAS_UAV                        (1 << 2)
+# define PSX_SHADER_USES_INPUT_COVERAGE_MASK       (1 << 1)
+
+#define GEN9_3DSTATE_RASTER		GEN9_3D(3, 0, 0x50)
+/* DW1 */
+# define RASTER_FRONT_WINDING_CCW                  (1 << 21)
+# define RASTER_CULL_BOTH                          (0 << 16)
+# define RASTER_CULL_NONE                          (1 << 16)
+# define RASTER_CULL_FRONT                         (2 << 16)
+# define RASTER_CULL_BACK                          (3 << 16)
+# define RASTER_SMOOTH_POINT_ENABLE                (1 << 13)
+# define RASTER_LINE_AA_ENABLE                     (1 << 2)
+# define RASTER_VIEWPORT_Z_CLIP_TEST_ENABLE        (1 << 0)
+
+#define GEN9_3DSTATE_SBE_SWIZ		GEN9_3D(3, 0, 0x51)
+#define GEN9_3DSTATE_WM_HZ_OP		GEN9_3D(3, 0, 0x52)
+
+#define GEN9_3DSTATE_COMPONENT_PACKING          GEN6_3D(3, 0, 0x55)
+
+
+
+#define GEN9_3DSTATE_DRAWING_RECTANGLE		GEN9_3D(3, 1, 0x00)
+#define GEN9_3DSTATE_SAMPLER_PALETTE_LOAD	GEN9_3D(3, 1, 0x02)
+#define GEN9_3DSTATE_CHROMA_KEY			GEN9_3D(3, 1, 0x04)
+
+#define GEN9_3DSTATE_POLY_STIPPLE_OFFSET	GEN9_3D(3, 1, 0x06)
+#define GEN9_3DSTATE_POLY_STIPPLE_PATTERN	GEN9_3D(3, 1, 0x07)
+#define GEN9_3DSTATE_LINE_STIPPLE		GEN9_3D(3, 1, 0x08)
+#define GEN9_3DSTATE_AA_LINE_PARAMS		GEN9_3D(3, 1, 0x0a)
+#define GEN9_3DSTATE_SAMPLER_PALETTE_LOAD1	GEN9_3D(3, 1, 0x0c)
+#define GEN9_3DSTATE_MONOFILTER_SIZE		GEN9_3D(3, 1, 0x11)
+#define GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_VS	GEN9_3D(3, 1, 0x12)
+#define GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_HS	GEN9_3D(3, 1, 0x13)
+#define GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_DS	GEN9_3D(3, 1, 0x14)
+#define GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_GS	GEN9_3D(3, 1, 0x15)
+#define GEN9_3DSTATE_PUSH_CONSTANT_ALLOC_PS	GEN9_3D(3, 1, 0x16)
+/* DW1 */
+# define PUSH_CONSTANT_BUFFER_OFFSET_SHIFT 16
+# define PUSH_CONSTANT_BUFFER_SIZE_SHIFT 0
+
+#define GEN9_3DSTATE_SO_DECL_LIST		GEN9_3D(3, 1, 0x17)
+#define GEN9_3DSTATE_SO_BUFFER			GEN9_3D(3, 1, 0x18)
+#define GEN9_3DSTATE_BINDING_TABLE_POOL_ALLOC	GEN9_3D(3, 1, 0x19)
+#define GEN9_3DSTATE_GATHER_BUFFER_POOL_ALLOC	GEN9_3D(3, 1, 0x1a)
+#define GEN9_3DSTATE_DX9_CONSTANT_BUFFER_POOL_ALLOC	GEN9_3D(3, 1, 0x1b)
+#define GEN9_3DSTATE_SAMPLE_PATTERN		GEN9_3D(3, 1, 0x1c)
+
+
+/* for GEN9_PIPE_CONTROL */
+#define GEN9_PIPE_CONTROL		GEN9_3D(3, 2, 0)
+#define PIPE_CONTROL_CS_STALL      (1 << 20)
+#define PIPE_CONTROL_NOWRITE       (0 << 14)
+#define PIPE_CONTROL_WRITE_QWORD   (1 << 14)
+#define PIPE_CONTROL_WRITE_DEPTH   (2 << 14)
+#define PIPE_CONTROL_WRITE_TIME    (3 << 14)
+#define PIPE_CONTROL_DEPTH_STALL   (1 << 13)
+#define PIPE_CONTROL_WC_FLUSH      (1 << 12)
+#define PIPE_CONTROL_IS_FLUSH      (1 << 11)
+#define PIPE_CONTROL_TC_FLUSH      (1 << 10)
+#define PIPE_CONTROL_NOTIFY_ENABLE (1 << 8)
+#define PIPE_CONTROL_GLOBAL_GTT    (1 << 2)
+#define PIPE_CONTROL_LOCAL_PGTT    (0 << 2)
+#define PIPE_CONTROL_STALL_AT_SCOREBOARD   (1 << 1)
+#define PIPE_CONTROL_DEPTH_CACHE_FLUSH	(1 << 0)
+
+
+#define GEN9_3DPRIMITIVE			GEN9_3D(3, 3, 0)
+
+/* 3DPRIMITIVE bits */
+#define VERTEX_SEQUENTIAL (0 << 15)
+#define VERTEX_RANDOM	  (1 << 15)
+
+#define ANISORATIO_2     0
+#define ANISORATIO_4     1
+#define ANISORATIO_6     2
+#define ANISORATIO_8     3
+#define ANISORATIO_10    4
+#define ANISORATIO_12    5
+#define ANISORATIO_14    6
+#define ANISORATIO_16    7
+
+#define BLENDFACTOR_ONE                 0x1
+#define BLENDFACTOR_SRC_COLOR           0x2
+#define BLENDFACTOR_SRC_ALPHA           0x3
+#define BLENDFACTOR_DST_ALPHA           0x4
+#define BLENDFACTOR_DST_COLOR           0x5
+#define BLENDFACTOR_SRC_ALPHA_SATURATE  0x6
+#define BLENDFACTOR_CONST_COLOR         0x7
+#define BLENDFACTOR_CONST_ALPHA         0x8
+#define BLENDFACTOR_SRC1_COLOR          0x9
+#define BLENDFACTOR_SRC1_ALPHA          0x0A
+#define BLENDFACTOR_ZERO                0x11
+#define BLENDFACTOR_INV_SRC_COLOR       0x12
+#define BLENDFACTOR_INV_SRC_ALPHA       0x13
+#define BLENDFACTOR_INV_DST_ALPHA       0x14
+#define BLENDFACTOR_INV_DST_COLOR       0x15
+#define BLENDFACTOR_INV_CONST_COLOR     0x17
+#define BLENDFACTOR_INV_CONST_ALPHA     0x18
+#define BLENDFACTOR_INV_SRC1_COLOR      0x19
+#define BLENDFACTOR_INV_SRC1_ALPHA      0x1A
+
+#define BLENDFUNCTION_ADD               0
+#define BLENDFUNCTION_SUBTRACT          1
+#define BLENDFUNCTION_REVERSE_SUBTRACT  2
+#define GEN9_BLENDFUNCTION_MIN               3
+#define BLENDFUNCTION_MAX               4
+
+#define ALPHATEST_FORMAT_UNORM8         0
+#define ALPHATEST_FORMAT_FLOAT32        1
+
+#define CHROMAKEY_KILL_ON_ANY_MATCH  0
+#define CHROMAKEY_REPLACE_BLACK      1
+
+#define CLIP_API_OGL     0
+#define CLIP_API_DX      1
+
+#define CLIPMODE_NORMAL              0
+#define CLIPMODE_CLIP_ALL            1
+#define CLIPMODE_CLIP_NON_REJECTED   2
+#define CLIPMODE_REJECT_ALL          3
+#define CLIPMODE_ACCEPT_ALL          4
+
+#define CLIP_NDCSPACE     0
+#define CLIP_SCREENSPACE  1
+
+#define COMPAREFUNCTION_ALWAYS       0
+#define COMPAREFUNCTION_NEVER        1
+#define COMPAREFUNCTION_LESS         2
+#define COMPAREFUNCTION_EQUAL        3
+#define COMPAREFUNCTION_LEQUAL       4
+#define COMPAREFUNCTION_GREATER      5
+#define COMPAREFUNCTION_NOTEQUAL     6
+#define COMPAREFUNCTION_GEQUAL       7
+
+#define COVERAGE_PIXELS_HALF     0
+#define COVERAGE_PIXELS_1        1
+#define COVERAGE_PIXELS_2        2
+#define COVERAGE_PIXELS_4        3
+
+#define DEPTHFORMAT_D32_FLOAT_S8X24_UINT     0
+#define DEPTHFORMAT_D32_FLOAT                1
+#define DEPTHFORMAT_D24_UNORM_S8_UINT        2
+#define DEPTHFORMAT_D16_UNORM                5
+
+#define FLOATING_POINT_IEEE_754        0
+#define FLOATING_POINT_NON_IEEE_754    1
+
+#define INDEX_BYTE     0
+#define INDEX_WORD     1
+#define INDEX_DWORD    2
+
+#define LOGICOPFUNCTION_CLEAR            0
+#define LOGICOPFUNCTION_NOR              1
+#define LOGICOPFUNCTION_AND_INVERTED     2
+#define LOGICOPFUNCTION_COPY_INVERTED    3
+#define LOGICOPFUNCTION_AND_REVERSE      4
+#define LOGICOPFUNCTION_INVERT           5
+#define LOGICOPFUNCTION_XOR              6
+#define LOGICOPFUNCTION_NAND             7
+#define LOGICOPFUNCTION_AND              8
+#define LOGICOPFUNCTION_EQUIV            9
+#define LOGICOPFUNCTION_NOOP             10
+#define LOGICOPFUNCTION_OR_INVERTED      11
+#define LOGICOPFUNCTION_COPY             12
+#define LOGICOPFUNCTION_OR_REVERSE       13
+#define LOGICOPFUNCTION_OR               14
+#define LOGICOPFUNCTION_SET              15
+
+#define MAPFILTER_NEAREST	0x0
+#define MAPFILTER_LINEAR	0x1
+#define MAPFILTER_ANISOTROPIC	0x2
+#define MAPFILTER_FLEXIBLE 	0x3
+#define MAPFILTER_MONO 		0x6
+
+#define MIPFILTER_NONE        0
+#define MIPFILTER_NEAREST     1
+#define MIPFILTER_LINEAR      3
+
+#define POLYGON_FRONT_FACING     0
+#define POLYGON_BACK_FACING      1
+
+#define PREFILTER_ALWAYS     0x0
+#define PREFILTER_NEVER      0x1
+#define PREFILTER_LESS       0x2
+#define PREFILTER_EQUAL      0x3
+#define PREFILTER_LEQUAL     0x4
+#define PREFILTER_GREATER    0x5
+#define PREFILTER_NOTEQUAL   0x6
+#define PREFILTER_GEQUAL     0x7
+
+#define RASTRULE_UPPER_LEFT  0
+#define RASTRULE_UPPER_RIGHT 1
+
+#define STENCILOP_KEEP               0
+#define STENCILOP_ZERO               1
+#define STENCILOP_REPLACE            2
+#define STENCILOP_INCRSAT            3
+#define STENCILOP_DECRSAT            4
+#define STENCILOP_INCR               5
+#define STENCILOP_DECR               6
+#define STENCILOP_INVERT             7
+
+#define SURFACE_MIPMAPLAYOUT_BELOW   0
+#define SURFACE_MIPMAPLAYOUT_RIGHT   1
+
+#define SURFACEFORMAT_R32G32B32A32_FLOAT             0x000
+#define SURFACEFORMAT_R32G32B32A32_SINT              0x001
+#define SURFACEFORMAT_R32G32B32A32_UINT              0x002
+#define SURFACEFORMAT_R32G32B32A32_UNORM             0x003
+#define SURFACEFORMAT_R32G32B32A32_SNORM             0x004
+#define SURFACEFORMAT_R64G64_FLOAT                   0x005
+#define SURFACEFORMAT_R32G32B32X32_FLOAT             0x006
+#define SURFACEFORMAT_R32G32B32A32_SSCALED           0x007
+#define SURFACEFORMAT_R32G32B32A32_USCALED           0x008
+#define SURFACEFORMAT_R32G32B32_FLOAT                0x040
+#define SURFACEFORMAT_R32G32B32_SINT                 0x041
+#define SURFACEFORMAT_R32G32B32_UINT                 0x042
+#define SURFACEFORMAT_R32G32B32_UNORM                0x043
+#define SURFACEFORMAT_R32G32B32_SNORM                0x044
+#define SURFACEFORMAT_R32G32B32_SSCALED              0x045
+#define SURFACEFORMAT_R32G32B32_USCALED              0x046
+#define SURFACEFORMAT_R16G16B16A16_UNORM             0x080
+#define SURFACEFORMAT_R16G16B16A16_SNORM             0x081
+#define SURFACEFORMAT_R16G16B16A16_SINT              0x082
+#define SURFACEFORMAT_R16G16B16A16_UINT              0x083
+#define SURFACEFORMAT_R16G16B16A16_FLOAT             0x084
+#define SURFACEFORMAT_R32G32_FLOAT                   0x085
+#define SURFACEFORMAT_R32G32_SINT                    0x086
+#define SURFACEFORMAT_R32G32_UINT                    0x087
+#define SURFACEFORMAT_R32_FLOAT_X8X24_TYPELESS       0x088
+#define SURFACEFORMAT_X32_TYPELESS_G8X24_UINT        0x089
+#define SURFACEFORMAT_L32A32_FLOAT                   0x08A
+#define SURFACEFORMAT_R32G32_UNORM                   0x08B
+#define SURFACEFORMAT_R32G32_SNORM                   0x08C
+#define SURFACEFORMAT_R64_FLOAT                      0x08D
+#define SURFACEFORMAT_R16G16B16X16_UNORM             0x08E
+#define SURFACEFORMAT_R16G16B16X16_FLOAT             0x08F
+#define SURFACEFORMAT_A32X32_FLOAT                   0x090
+#define SURFACEFORMAT_L32X32_FLOAT                   0x091
+#define SURFACEFORMAT_I32X32_FLOAT                   0x092
+#define SURFACEFORMAT_R16G16B16A16_SSCALED           0x093
+#define SURFACEFORMAT_R16G16B16A16_USCALED           0x094
+#define SURFACEFORMAT_R32G32_SSCALED                 0x095
+#define SURFACEFORMAT_R32G32_USCALED                 0x096
+#define SURFACEFORMAT_B8G8R8A8_UNORM                 0x0C0
+#define SURFACEFORMAT_B8G8R8A8_UNORM_SRGB            0x0C1
+#define SURFACEFORMAT_R10G10B10A2_UNORM              0x0C2
+#define SURFACEFORMAT_R10G10B10A2_UNORM_SRGB         0x0C3
+#define SURFACEFORMAT_R10G10B10A2_UINT               0x0C4
+#define SURFACEFORMAT_R10G10B10_SNORM_A2_UNORM       0x0C5
+#define SURFACEFORMAT_R8G8B8A8_UNORM                 0x0C7
+#define SURFACEFORMAT_R8G8B8A8_UNORM_SRGB            0x0C8
+#define SURFACEFORMAT_R8G8B8A8_SNORM                 0x0C9
+#define SURFACEFORMAT_R8G8B8A8_SINT                  0x0CA
+#define SURFACEFORMAT_R8G8B8A8_UINT                  0x0CB
+#define SURFACEFORMAT_R16G16_UNORM                   0x0CC
+#define SURFACEFORMAT_R16G16_SNORM                   0x0CD
+#define SURFACEFORMAT_R16G16_SINT                    0x0CE
+#define SURFACEFORMAT_R16G16_UINT                    0x0CF
+#define SURFACEFORMAT_R16G16_FLOAT                   0x0D0
+#define SURFACEFORMAT_B10G10R10A2_UNORM              0x0D1
+#define SURFACEFORMAT_B10G10R10A2_UNORM_SRGB         0x0D2
+#define SURFACEFORMAT_R11G11B10_FLOAT                0x0D3
+#define SURFACEFORMAT_R32_SINT                       0x0D6
+#define SURFACEFORMAT_R32_UINT                       0x0D7
+#define SURFACEFORMAT_R32_FLOAT                      0x0D8
+#define SURFACEFORMAT_R24_UNORM_X8_TYPELESS          0x0D9
+#define SURFACEFORMAT_X24_TYPELESS_G8_UINT           0x0DA
+#define SURFACEFORMAT_L16A16_UNORM                   0x0DF
+#define SURFACEFORMAT_I24X8_UNORM                    0x0E0
+#define SURFACEFORMAT_L24X8_UNORM                    0x0E1
+#define SURFACEFORMAT_A24X8_UNORM                    0x0E2
+#define SURFACEFORMAT_I32_FLOAT                      0x0E3
+#define SURFACEFORMAT_L32_FLOAT                      0x0E4
+#define SURFACEFORMAT_A32_FLOAT                      0x0E5
+#define SURFACEFORMAT_B8G8R8X8_UNORM                 0x0E9
+#define SURFACEFORMAT_B8G8R8X8_UNORM_SRGB            0x0EA
+#define SURFACEFORMAT_R8G8B8X8_UNORM                 0x0EB
+#define SURFACEFORMAT_R8G8B8X8_UNORM_SRGB            0x0EC
+#define SURFACEFORMAT_R9G9B9E5_SHAREDEXP             0x0ED
+#define SURFACEFORMAT_B10G10R10X2_UNORM              0x0EE
+#define SURFACEFORMAT_L16A16_FLOAT                   0x0F0
+#define SURFACEFORMAT_R32_UNORM                      0x0F1
+#define SURFACEFORMAT_R32_SNORM                      0x0F2
+#define SURFACEFORMAT_R10G10B10X2_USCALED            0x0F3
+#define SURFACEFORMAT_R8G8B8A8_SSCALED               0x0F4
+#define SURFACEFORMAT_R8G8B8A8_USCALED               0x0F5
+#define SURFACEFORMAT_R16G16_SSCALED                 0x0F6
+#define SURFACEFORMAT_R16G16_USCALED                 0x0F7
+#define SURFACEFORMAT_R32_SSCALED                    0x0F8
+#define SURFACEFORMAT_R32_USCALED                    0x0F9
+#define SURFACEFORMAT_B5G6R5_UNORM                   0x100
+#define SURFACEFORMAT_B5G6R5_UNORM_SRGB              0x101
+#define SURFACEFORMAT_B5G5R5A1_UNORM                 0x102
+#define SURFACEFORMAT_B5G5R5A1_UNORM_SRGB            0x103
+#define SURFACEFORMAT_B4G4R4A4_UNORM                 0x104
+#define SURFACEFORMAT_B4G4R4A4_UNORM_SRGB            0x105
+#define SURFACEFORMAT_R8G8_UNORM                     0x106
+#define SURFACEFORMAT_R8G8_SNORM                     0x107
+#define SURFACEFORMAT_R8G8_SINT                      0x108
+#define SURFACEFORMAT_R8G8_UINT                      0x109
+#define SURFACEFORMAT_R16_UNORM                      0x10A
+#define SURFACEFORMAT_R16_SNORM                      0x10B
+#define SURFACEFORMAT_R16_SINT                       0x10C
+#define SURFACEFORMAT_R16_UINT                       0x10D
+#define SURFACEFORMAT_R16_FLOAT                      0x10E
+#define SURFACEFORMAT_I16_UNORM                      0x111
+#define SURFACEFORMAT_L16_UNORM                      0x112
+#define SURFACEFORMAT_A16_UNORM                      0x113
+#define SURFACEFORMAT_L8A8_UNORM                     0x114
+#define SURFACEFORMAT_I16_FLOAT                      0x115
+#define SURFACEFORMAT_L16_FLOAT                      0x116
+#define SURFACEFORMAT_A16_FLOAT                      0x117
+#define SURFACEFORMAT_R5G5_SNORM_B6_UNORM            0x119
+#define SURFACEFORMAT_B5G5R5X1_UNORM                 0x11A
+#define SURFACEFORMAT_B5G5R5X1_UNORM_SRGB            0x11B
+#define SURFACEFORMAT_R8G8_SSCALED                   0x11C
+#define SURFACEFORMAT_R8G8_USCALED                   0x11D
+#define SURFACEFORMAT_R16_SSCALED                    0x11E
+#define SURFACEFORMAT_R16_USCALED                    0x11F
+#define SURFACEFORMAT_R8_UNORM                       0x140
+#define SURFACEFORMAT_R8_SNORM                       0x141
+#define SURFACEFORMAT_R8_SINT                        0x142
+#define SURFACEFORMAT_R8_UINT                        0x143
+#define SURFACEFORMAT_A8_UNORM                       0x144
+#define SURFACEFORMAT_I8_UNORM                       0x145
+#define SURFACEFORMAT_L8_UNORM                       0x146
+#define SURFACEFORMAT_P4A4_UNORM                     0x147
+#define SURFACEFORMAT_A4P4_UNORM                     0x148
+#define SURFACEFORMAT_R8_SSCALED                     0x149
+#define SURFACEFORMAT_R8_USCALED                     0x14A
+#define SURFACEFORMAT_R1_UINT                        0x181
+#define SURFACEFORMAT_YCRCB_NORMAL                   0x182
+#define SURFACEFORMAT_YCRCB_SWAPUVY                  0x183
+#define SURFACEFORMAT_BC1_UNORM                      0x186
+#define SURFACEFORMAT_BC2_UNORM                      0x187
+#define SURFACEFORMAT_BC3_UNORM                      0x188
+#define SURFACEFORMAT_BC4_UNORM                      0x189
+#define SURFACEFORMAT_BC5_UNORM                      0x18A
+#define SURFACEFORMAT_BC1_UNORM_SRGB                 0x18B
+#define SURFACEFORMAT_BC2_UNORM_SRGB                 0x18C
+#define SURFACEFORMAT_BC3_UNORM_SRGB                 0x18D
+#define SURFACEFORMAT_MONO8                          0x18E
+#define SURFACEFORMAT_YCRCB_SWAPUV                   0x18F
+#define SURFACEFORMAT_YCRCB_SWAPY                    0x190
+#define SURFACEFORMAT_DXT1_RGB                       0x191
+#define SURFACEFORMAT_FXT1                           0x192
+#define SURFACEFORMAT_R8G8B8_UNORM                   0x193
+#define SURFACEFORMAT_R8G8B8_SNORM                   0x194
+#define SURFACEFORMAT_R8G8B8_SSCALED                 0x195
+#define SURFACEFORMAT_R8G8B8_USCALED                 0x196
+#define SURFACEFORMAT_R64G64B64A64_FLOAT             0x197
+#define SURFACEFORMAT_R64G64B64_FLOAT                0x198
+#define SURFACEFORMAT_BC4_SNORM                      0x199
+#define SURFACEFORMAT_BC5_SNORM                      0x19A
+#define SURFACEFORMAT_R16G16B16_UNORM                0x19C
+#define SURFACEFORMAT_R16G16B16_SNORM                0x19D
+#define SURFACEFORMAT_R16G16B16_SSCALED              0x19E
+#define SURFACEFORMAT_R16G16B16_USCALED              0x19F
+
+#define SURFACE_1D      0
+#define SURFACE_2D      1
+#define SURFACE_3D      2
+#define SURFACE_CUBE    3
+#define SURFACE_BUFFER  4
+#define SURFACE_NULL    7
+
+#define TEXCOORDMODE_WRAP            0
+#define TEXCOORDMODE_MIRROR          1
+#define TEXCOORDMODE_CLAMP           2
+#define TEXCOORDMODE_CUBE            3
+#define TEXCOORDMODE_CLAMP_BORDER    4
+#define TEXCOORDMODE_MIRROR_ONCE     5
+
+#define THREAD_PRIORITY_NORMAL   0
+#define THREAD_PRIORITY_HIGH     1
+
+#define VERTEX_SUBPIXEL_PRECISION_8BITS  0
+#define VERTEX_SUBPIXEL_PRECISION_4BITS  1
+
+#define COMPONENT_NOSTORE      0
+#define COMPONENT_STORE_SRC    1
+#define COMPONENT_STORE_0      2
+#define COMPONENT_STORE_1_FLT  3
+#define COMPONENT_STORE_1_INT  4
+#define COMPONENT_STORE_VID    5
+#define COMPONENT_STORE_IID    6
+#define COMPONENT_STORE_PID    7
+
+/* Execution Unit (EU) defines
+ */
+
+#define GEN9_ALIGN_1   0
+#define GEN9_ALIGN_16  1
+
+#define GEN9_ADDRESS_DIRECT                        0
+#define GEN9_ADDRESS_REGISTER_INDIRECT_REGISTER    1
+
+#define GEN9_CHANNEL_X     0
+#define GEN9_CHANNEL_Y     1
+#define GEN9_CHANNEL_Z     2
+#define GEN9_CHANNEL_W     3
+
+#define GEN9_COMPRESSION_NONE          0
+#define GEN9_COMPRESSION_2NDHALF       1
+#define GEN9_COMPRESSION_COMPRESSED    2
+
+#define GEN9_CONDITIONAL_NONE  0
+#define GEN9_CONDITIONAL_Z     1
+#define GEN9_CONDITIONAL_NZ    2
+#define GEN9_CONDITIONAL_EQ    1	/* Z */
+#define GEN9_CONDITIONAL_NEQ   2	/* NZ */
+#define GEN9_CONDITIONAL_G     3
+#define GEN9_CONDITIONAL_GE    4
+#define GEN9_CONDITIONAL_L     5
+#define GEN9_CONDITIONAL_LE    6
+#define GEN9_CONDITIONAL_C     7
+#define GEN9_CONDITIONAL_O     8
+
+#define GEN9_DEBUG_NONE        0
+#define GEN9_DEBUG_BREAKPOINT  1
+
+#define GEN9_DEPENDENCY_NORMAL         0
+#define GEN9_DEPENDENCY_NOTCLEARED     1
+#define GEN9_DEPENDENCY_NOTCHECKED     2
+#define GEN9_DEPENDENCY_DISABLE        3
+
+#define GEN9_EXECUTE_1     0
+#define GEN9_EXECUTE_2     1
+#define GEN9_EXECUTE_4     2
+#define GEN9_EXECUTE_8     3
+#define GEN9_EXECUTE_16    4
+#define GEN9_EXECUTE_32    5
+
+#define GEN9_HORIZONTAL_STRIDE_0   0
+#define GEN9_HORIZONTAL_STRIDE_1   1
+#define GEN9_HORIZONTAL_STRIDE_2   2
+#define GEN9_HORIZONTAL_STRIDE_4   3
+
+#define GEN9_INSTRUCTION_NORMAL    0
+#define GEN9_INSTRUCTION_SATURATE  1
+
+#define GEN9_OPCODE_MOV        1
+#define GEN9_OPCODE_SEL        2
+#define GEN9_OPCODE_NOT        4
+#define GEN9_OPCODE_AND        5
+#define GEN9_OPCODE_OR         6
+#define GEN9_OPCODE_XOR        7
+#define GEN9_OPCODE_SHR        8
+#define GEN9_OPCODE_SHL        9
+#define GEN9_OPCODE_RSR        10
+#define GEN9_OPCODE_RSL        11
+#define GEN9_OPCODE_ASR        12
+#define GEN9_OPCODE_CMP        16
+#define GEN9_OPCODE_JMPI       32
+#define GEN9_OPCODE_IF         34
+#define GEN9_OPCODE_IFF        35
+#define GEN9_OPCODE_ELSE       36
+#define GEN9_OPCODE_ENDIF      37
+#define GEN9_OPCODE_DO         38
+#define GEN9_OPCODE_WHILE      39
+#define GEN9_OPCODE_BREAK      40
+#define GEN9_OPCODE_CONTINUE   41
+#define GEN9_OPCODE_HALT       42
+#define GEN9_OPCODE_MSAVE      44
+#define GEN9_OPCODE_MRESTORE   45
+#define GEN9_OPCODE_PUSH       46
+#define GEN9_OPCODE_POP        47
+#define GEN9_OPCODE_WAIT       48
+#define GEN9_OPCODE_SEND       49
+#define GEN9_OPCODE_ADD        64
+#define GEN9_OPCODE_MUL        65
+#define GEN9_OPCODE_AVG        66
+#define GEN9_OPCODE_FRC        67
+#define GEN9_OPCODE_RNDU       68
+#define GEN9_OPCODE_RNDD       69
+#define GEN9_OPCODE_RNDE       70
+#define GEN9_OPCODE_RNDZ       71
+#define GEN9_OPCODE_MAC        72
+#define GEN9_OPCODE_MACH       73
+#define GEN9_OPCODE_LZD        74
+#define GEN9_OPCODE_SAD2       80
+#define GEN9_OPCODE_SADA2      81
+#define GEN9_OPCODE_DP4        84
+#define GEN9_OPCODE_DPH        85
+#define GEN9_OPCODE_DP3        86
+#define GEN9_OPCODE_DP2        87
+#define GEN9_OPCODE_DPA2       88
+#define GEN9_OPCODE_LINE       89
+#define GEN9_OPCODE_NOP        126
+
+#define GEN9_PREDICATE_NONE             0
+#define GEN9_PREDICATE_NORMAL           1
+#define GEN9_PREDICATE_ALIGN1_ANYV             2
+#define GEN9_PREDICATE_ALIGN1_ALLV             3
+#define GEN9_PREDICATE_ALIGN1_ANY2H            4
+#define GEN9_PREDICATE_ALIGN1_ALL2H            5
+#define GEN9_PREDICATE_ALIGN1_ANY4H            6
+#define GEN9_PREDICATE_ALIGN1_ALL4H            7
+#define GEN9_PREDICATE_ALIGN1_ANY8H            8
+#define GEN9_PREDICATE_ALIGN1_ALL8H            9
+#define GEN9_PREDICATE_ALIGN1_ANY16H           10
+#define GEN9_PREDICATE_ALIGN1_ALL16H           11
+#define GEN9_PREDICATE_ALIGN16_REPLICATE_X     2
+#define GEN9_PREDICATE_ALIGN16_REPLICATE_Y     3
+#define GEN9_PREDICATE_ALIGN16_REPLICATE_Z     4
+#define GEN9_PREDICATE_ALIGN16_REPLICATE_W     5
+#define GEN9_PREDICATE_ALIGN16_ANY4H           6
+#define GEN9_PREDICATE_ALIGN16_ALL4H           7
+
+#define GEN9_ARCHITECTURE_REGISTER_FILE    0
+#define GEN9_GENERAL_REGISTER_FILE         1
+#define GEN9_MESSAGE_REGISTER_FILE         2
+#define GEN9_IMMEDIATE_VALUE               3
+
+#define GEN9_REGISTER_TYPE_UD  0
+#define GEN9_REGISTER_TYPE_D   1
+#define GEN9_REGISTER_TYPE_UW  2
+#define GEN9_REGISTER_TYPE_W   3
+#define GEN9_REGISTER_TYPE_UB  4
+#define GEN9_REGISTER_TYPE_B   5
+#define GEN9_REGISTER_TYPE_VF  5	/* packed float vector, immediates only? */
+#define GEN9_REGISTER_TYPE_HF  6
+#define GEN9_REGISTER_TYPE_V   6	/* packed int vector, immediates only, uword dest only */
+#define GEN9_REGISTER_TYPE_F   7
+
+#define GEN9_ARF_NULL                  0x00
+#define GEN9_ARF_ADDRESS               0x10
+#define GEN9_ARF_ACCUMULATOR           0x20
+#define GEN9_ARF_FLAG                  0x30
+#define GEN9_ARF_MASK                  0x40
+#define GEN9_ARF_MASK_STACK            0x50
+#define GEN9_ARF_MASK_STACK_DEPTH      0x60
+#define GEN9_ARF_STATE                 0x70
+#define GEN9_ARF_CONTROL               0x80
+#define GEN9_ARF_NOTIFICATION_COUNT    0x90
+#define GEN9_ARF_IP                    0xA0
+
+#define GEN9_AMASK   0
+#define GEN9_IMASK   1
+#define GEN9_LMASK   2
+#define GEN9_CMASK   3
+
+#define GEN9_THREAD_NORMAL     0
+#define GEN9_THREAD_ATOMIC     1
+#define GEN9_THREAD_SWITCH     2
+
+#define GEN9_VERTICAL_STRIDE_0                 0
+#define GEN9_VERTICAL_STRIDE_1                 1
+#define GEN9_VERTICAL_STRIDE_2                 2
+#define GEN9_VERTICAL_STRIDE_4                 3
+#define GEN9_VERTICAL_STRIDE_8                 4
+#define GEN9_VERTICAL_STRIDE_16                5
+#define GEN9_VERTICAL_STRIDE_32                6
+#define GEN9_VERTICAL_STRIDE_64                7
+#define GEN9_VERTICAL_STRIDE_128               8
+#define GEN9_VERTICAL_STRIDE_256               9
+#define GEN9_VERTICAL_STRIDE_ONE_DIMENSIONAL   0xF
+
+#define GEN9_WIDTH_1       0
+#define GEN9_WIDTH_2       1
+#define GEN9_WIDTH_4       2
+#define GEN9_WIDTH_8       3
+#define GEN9_WIDTH_16      4
+
+#define GEN9_STATELESS_BUFFER_BOUNDARY_1K      0
+#define GEN9_STATELESS_BUFFER_BOUNDARY_2K      1
+#define GEN9_STATELESS_BUFFER_BOUNDARY_4K      2
+#define GEN9_STATELESS_BUFFER_BOUNDARY_8K      3
+#define GEN9_STATELESS_BUFFER_BOUNDARY_16K     4
+#define GEN9_STATELESS_BUFFER_BOUNDARY_32K     5
+#define GEN9_STATELESS_BUFFER_BOUNDARY_64K     6
+#define GEN9_STATELESS_BUFFER_BOUNDARY_128K    7
+#define GEN9_STATELESS_BUFFER_BOUNDARY_256K    8
+#define GEN9_STATELESS_BUFFER_BOUNDARY_512K    9
+#define GEN9_STATELESS_BUFFER_BOUNDARY_1M      10
+#define GEN9_STATELESS_BUFFER_BOUNDARY_2M      11
+
+#define GEN9_POLYGON_FACING_FRONT      0
+#define GEN9_POLYGON_FACING_BACK       1
+
+#define GEN9_MESSAGE_TARGET_NULL               0
+#define GEN9_MESSAGE_TARGET_MATH               1
+#define GEN9_MESSAGE_TARGET_SAMPLER            2
+#define GEN9_MESSAGE_TARGET_GATEWAY            3
+#define GEN9_MESSAGE_TARGET_DATAPORT_READ      4
+#define GEN9_MESSAGE_TARGET_DATAPORT_WRITE     5
+#define GEN9_MESSAGE_TARGET_URB                6
+#define GEN9_MESSAGE_TARGET_THREAD_SPAWNER     7
+
+#define GEN9_SAMPLER_RETURN_FORMAT_FLOAT32     0
+#define GEN9_SAMPLER_RETURN_FORMAT_UINT32      2
+#define GEN9_SAMPLER_RETURN_FORMAT_SINT32      3
+
+#define GEN9_SAMPLER_MESSAGE_SIMD8_SAMPLE              0
+#define GEN9_SAMPLER_MESSAGE_SIMD16_SAMPLE             0
+#define GEN9_SAMPLER_MESSAGE_SIMD16_SAMPLE_BIAS        0
+#define GEN9_SAMPLER_MESSAGE_SIMD8_KILLPIX             1
+#define GEN9_SAMPLER_MESSAGE_SIMD4X2_SAMPLE_LOD        1
+#define GEN9_SAMPLER_MESSAGE_SIMD16_SAMPLE_LOD         1
+#define GEN9_SAMPLER_MESSAGE_SIMD4X2_SAMPLE_GRADIENTS  2
+#define GEN9_SAMPLER_MESSAGE_SIMD8_SAMPLE_GRADIENTS    2
+#define GEN9_SAMPLER_MESSAGE_SIMD4X2_SAMPLE_COMPARE    0
+#define GEN9_SAMPLER_MESSAGE_SIMD16_SAMPLE_COMPARE     2
+#define GEN9_SAMPLER_MESSAGE_SIMD4X2_RESINFO           2
+#define GEN9_SAMPLER_MESSAGE_SIMD8_RESINFO             2
+#define GEN9_SAMPLER_MESSAGE_SIMD16_RESINFO            2
+#define GEN9_SAMPLER_MESSAGE_SIMD4X2_LD                3
+#define GEN9_SAMPLER_MESSAGE_SIMD8_LD                  3
+#define GEN9_SAMPLER_MESSAGE_SIMD16_LD                 3
+
+#define GEN9_DATAPORT_OWORD_BLOCK_1_OWORDLOW   0
+#define GEN9_DATAPORT_OWORD_BLOCK_1_OWORDHIGH  1
+#define GEN9_DATAPORT_OWORD_BLOCK_2_OWORDS     2
+#define GEN9_DATAPORT_OWORD_BLOCK_4_OWORDS     3
+#define GEN9_DATAPORT_OWORD_BLOCK_8_OWORDS     4
+
+#define GEN9_DATAPORT_OWORD_DUAL_BLOCK_1OWORD     0
+#define GEN9_DATAPORT_OWORD_DUAL_BLOCK_4OWORDS    2
+
+#define GEN9_DATAPORT_DWORD_SCATTERED_BLOCK_8DWORDS   2
+#define GEN9_DATAPORT_DWORD_SCATTERED_BLOCK_16DWORDS  3
+
+#define GEN9_DATAPORT_READ_MESSAGE_OWORD_BLOCK_READ          0
+#define GEN9_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ     1
+#define GEN9_DATAPORT_READ_MESSAGE_DWORD_BLOCK_READ          2
+#define GEN9_DATAPORT_READ_MESSAGE_DWORD_SCATTERED_READ      3
+
+#define GEN9_DATAPORT_READ_TARGET_DATA_CACHE      0
+#define GEN9_DATAPORT_READ_TARGET_RENDER_CACHE    1
+#define GEN9_DATAPORT_READ_TARGET_SAMPLER_CACHE   2
+
+#define GEN9_DATAPORT_RENDER_TARGET_WRITE_SIMD16_SINGLE_SOURCE                0
+#define GEN9_DATAPORT_RENDER_TARGET_WRITE_SIMD16_SINGLE_SOURCE_REPLICATED     1
+#define GEN9_DATAPORT_RENDER_TARGET_WRITE_SIMD8_DUAL_SOURCE_SUBSPAN01         2
+#define GEN9_DATAPORT_RENDER_TARGET_WRITE_SIMD8_DUAL_SOURCE_SUBSPAN23         3
+#define GEN9_DATAPORT_RENDER_TARGET_WRITE_SIMD8_SINGLE_SOURCE_SUBSPAN01       4
+
+#define GEN9_DATAPORT_WRITE_MESSAGE_OWORD_BLOCK_WRITE                0
+#define GEN9_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE           1
+#define GEN9_DATAPORT_WRITE_MESSAGE_DWORD_BLOCK_WRITE                2
+#define GEN9_DATAPORT_WRITE_MESSAGE_DWORD_SCATTERED_WRITE            3
+#define GEN9_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE              4
+#define GEN9_DATAPORT_WRITE_MESSAGE_STREAMED_VERTEX_BUFFER_WRITE     5
+#define GEN9_DATAPORT_WRITE_MESSAGE_FLUSH_RENDER_CACHE               7
+
+#define GEN9_MATH_FUNCTION_INV                              1
+#define GEN9_MATH_FUNCTION_LOG                              2
+#define GEN9_MATH_FUNCTION_EXP                              3
+#define GEN9_MATH_FUNCTION_SQRT                             4
+#define GEN9_MATH_FUNCTION_RSQ                              5
+#define GEN9_MATH_FUNCTION_SIN                              6 /* was 7 */
+#define GEN9_MATH_FUNCTION_COS                              7 /* was 8 */
+#define GEN9_MATH_FUNCTION_SINCOS                           8 /* was 6 */
+#define GEN9_MATH_FUNCTION_TAN                              9
+#define GEN9_MATH_FUNCTION_POW                              10
+#define GEN9_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER   11
+#define GEN9_MATH_FUNCTION_INT_DIV_QUOTIENT                 12
+#define GEN9_MATH_FUNCTION_INT_DIV_REMAINDER                13
+
+#define GEN9_MATH_INTEGER_UNSIGNED     0
+#define GEN9_MATH_INTEGER_SIGNED       1
+
+#define GEN9_MATH_PRECISION_FULL        0
+#define GEN9_MATH_PRECISION_PARTIAL     1
+
+#define GEN9_MATH_SATURATE_NONE         0
+#define GEN9_MATH_SATURATE_SATURATE     1
+
+#define GEN9_MATH_DATA_VECTOR  0
+#define GEN9_MATH_DATA_SCALAR  1
+
+#define GEN9_URB_OPCODE_WRITE  0
+
+#define GEN9_URB_SWIZZLE_NONE          0
+#define GEN9_URB_SWIZZLE_INTERLEAVE    1
+#define GEN9_URB_SWIZZLE_TRANSPOSE     2
+
+#define GEN9_SCRATCH_SPACE_SIZE_1K     0
+#define GEN9_SCRATCH_SPACE_SIZE_2K     1
+#define GEN9_SCRATCH_SPACE_SIZE_4K     2
+#define GEN9_SCRATCH_SPACE_SIZE_8K     3
+#define GEN9_SCRATCH_SPACE_SIZE_16K    4
+#define GEN9_SCRATCH_SPACE_SIZE_32K    5
+#define GEN9_SCRATCH_SPACE_SIZE_64K    6
+#define GEN9_SCRATCH_SPACE_SIZE_128K   7
+#define GEN9_SCRATCH_SPACE_SIZE_256K   8
+#define GEN9_SCRATCH_SPACE_SIZE_512K   9
+#define GEN9_SCRATCH_SPACE_SIZE_1M     10
+#define GEN9_SCRATCH_SPACE_SIZE_2M     11
+
+struct gen9_blend_state {
+	struct {
+		/* 00 */ uint32_t pad:19;
+		/* 19 */ uint32_t y_dither_offset:2;
+		/* 21 */ uint32_t x_dither_offset:2;
+		/* 23 */ uint32_t color_dither_enable:1;
+		/* 24 */ uint32_t alpha_test_function:3;
+		/* 27 */ uint32_t alpha_test:1;
+		/* 28 */ uint32_t alpha_to_coverage_dither:1;
+		/* 29 */ uint32_t alpha_to_one:1;
+		/* 30 */ uint32_t ia_blend:1;
+		/* 31 */ uint32_t alpha_to_coverage:1;
+	} common;
+
+	struct {
+		/* 00 */ uint32_t write_disable_blue:1;
+		/* 01 */ uint32_t write_disable_green:1;
+		/* 02 */ uint32_t write_disable_red:1;
+		/* 03 */ uint32_t write_disable_alpha:1;
+		/* 04 */ uint32_t pad0:1;
+		/* 05 */ uint32_t alpha_blend_function:3;
+		/* 08 */ uint32_t dest_alpha_blend_factor:5;
+		/* 13 */ uint32_t source_alpha_blend_factor:5;
+		/* 18 */ uint32_t color_blend_function:3;
+		/* 21 */ uint32_t dest_blend_factor:5;
+		/* 26 */ uint32_t source_blend_factor:5;
+		/* 31 */ uint32_t color_blend:1;
+		/* 32 */ uint32_t post_blend_clamp:1;
+		/* 33 */ uint32_t pre_blend_clamp:1;
+		/* 34 */ uint32_t color_clamp_range:2;
+		/* 36 */ uint32_t pre_blend_source_only_clamp:1;
+		/* 37 */ uint32_t pad1:22;
+		/* 59 */ uint32_t logic_op_function:4;
+		/* 63 */ uint32_t logic_op:1;
+	} rt;
+};
+
+struct gen9_color_calc_state {
+	struct {
+		/* 00 */ uint32_t alpha_test_format:1;
+		/* 01 */ uint32_t pad0:14;
+		/* 15 */ uint32_t round_disable:1;
+		/* 16 */ uint32_t bf_stencil_ref:8;
+		/* 24 */ uint32_t stencil_ref:8;
+	} cc0;
+
+	union {
+		float alpha_ref_f;
+		struct {
+			uint32_t ui:8;
+			uint32_t pad0:24;
+		} alpha_ref_fi;
+	} cc1;
+
+	float constant_r;
+	float constant_g;
+	float constant_b;
+	float constant_a;
+};
+
+struct gen9_sampler_state {
+	struct {
+		/* 00 */ unsigned int aniso_algorithm:1;
+		/* 01 */ unsigned int lod_bias:13;
+		/* 14 */ unsigned int min_filter:3;
+		/* 17 */ unsigned int mag_filter:3;
+		/* 20 */ unsigned int mip_filter:2;
+		/* 22 */ unsigned int base_level:5;
+		/* 27 */ unsigned int lod_preclamp:2;
+		/* 29 */ unsigned int default_color_mode:1;
+		/* 30 */ unsigned int flexible_filter_clamp:1;
+		/* 31 */ unsigned int disable:1;
+	} ss0;
+
+	struct {
+		/* 00 */ unsigned int cube_control_mode:1;
+		/* 01 */ unsigned int shadow_function:3;
+		/* 04 */ unsigned int chroma_key_mode:1;
+		/* 05 */ unsigned int chroma_key_index:2;
+		/* 07 */ unsigned int chroma_key_enable:1;
+		/* 08 */ unsigned int max_lod:12;
+		/* 20 */ unsigned int min_lod:12;
+	} ss1;
+
+	struct {
+		unsigned int pad:6;
+		unsigned int default_color_pointer:26;
+	} ss2;
+
+	struct {
+		/* 00 */ unsigned int r_wrap_mode:3;
+		/* 03 */ unsigned int t_wrap_mode:3;
+		/* 06 */ unsigned int s_wrap_mode:3;
+		/* 09 */ unsigned int pad:1;
+		/* 10 */ unsigned int non_normalized_coord:1;
+		/* 11 */ unsigned int trilinear_quality:2;
+		/* 13 */ unsigned int address_round:6;
+		/* 19 */ unsigned int max_aniso:3;
+		/* 22 */ unsigned int pad0:2;
+		/* 24 */ unsigned int non_separable_filter:8;
+	} ss3;
+};
+
+/* Surface state DW0 */
+#define SURFACE_RC_READ_WRITE	(1 << 8)
+#define SURFACE_TILED		(1 << 13)
+#define SURFACE_TILED_Y		(1 << 12)
+#define SURFACE_FORMAT_SHIFT	18
+#define SURFACE_VALIGN_1	(0 << 16) /* reserved! */
+#define SURFACE_VALIGN_4	(1 << 16)
+#define SURFACE_VALIGN_8	(2 << 16)
+#define SURFACE_VALIGN_16	(3 << 16)
+#define SURFACE_HALIGN_1	(0 << 14) /* reserved! */
+#define SURFACE_HALIGN_4	(1 << 14)
+#define SURFACE_HALIGN_8	(2 << 14)
+#define SURFACE_HALIGN_16	(3 << 14)
+#define SURFACE_TYPE_SHIFT		29
+
+/* Surface state DW2 */
+#define SURFACE_HEIGHT_SHIFT        16
+#define SURFACE_WIDTH_SHIFT         0
+
+/* Surface state DW3 */
+#define SURFACE_DEPTH_SHIFT         21
+#define SURFACE_PITCH_SHIFT         0
+
+#define SWIZZLE_ZERO		0
+#define SWIZZLE_ONE		1
+#define SWIZZLE_RED		4
+#define SWIZZLE_GREEN		5
+#define SWIZZLE_BLUE		6
+#define SWIZZLE_ALPHA		7
+#define __SURFACE_SWIZZLE(r,g,b,a) \
+	((a) << 16 | (b) << 19 | (g) << 22 | (r) << 25)
+#define SURFACE_SWIZZLE(r,g,b,a) \
+	__SURFACE_SWIZZLE(SWIZZLE_##r, SWIZZLE_##g, SWIZZLE_##b, SWIZZLE_##a)
+
+typedef enum {
+	SAMPLER_FILTER_NEAREST = 0,
+	SAMPLER_FILTER_BILINEAR,
+	FILTER_COUNT
+} sampler_filter_t;
+
+typedef enum {
+	SAMPLER_EXTEND_NONE = 0,
+	SAMPLER_EXTEND_REPEAT,
+	SAMPLER_EXTEND_PAD,
+	SAMPLER_EXTEND_REFLECT,
+	EXTEND_COUNT
+} sampler_extend_t;
+
+#endif
diff --git a/src/sna/sna.h b/src/sna/sna.h
index 4c50947..c9612b4 100644
--- a/src/sna/sna.h
+++ b/src/sna/sna.h
@@ -406,6 +406,7 @@ struct sna {
 		struct gen6_render_state gen6;
 		struct gen7_render_state gen7;
 		struct gen8_render_state gen8;
+		struct gen9_render_state gen9;
 	} render_state;
 
 	/* Broken-out options. */
diff --git a/src/sna/sna_accel.c b/src/sna/sna_accel.c
index 684d58e..48dcb58 100644
--- a/src/sna/sna_accel.c
+++ b/src/sna/sna_accel.c
@@ -18015,8 +18015,7 @@ static bool sna_option_accel_blt(struct sna *sna)
 {
 	const char *s;
 
-	if (sna->kgem.gen >= 0110)
-		return true;
+	assert(sna->kgem.gen < 0120);
 
 	s = xf86GetOptValString(sna->Options, OPTION_ACCEL_METHOD);
 	if (s == NULL)
@@ -18108,6 +18107,8 @@ bool sna_accel_init(ScreenPtr screen, struct sna *sna)
 		sna_render_mark_wedged(sna);
 	} else if (sna_option_accel_blt(sna))
 		(void)backend;
+	else if (sna->kgem.gen >= 0110)
+		backend = gen9_render_init(sna, backend);
 	else if (sna->kgem.gen >= 0100)
 		backend = gen8_render_init(sna, backend);
 	else if (sna->kgem.gen >= 070)
diff --git a/src/sna/sna_render.h b/src/sna/sna_render.h
index fa1ca8e..aa2e676 100644
--- a/src/sna/sna_render.h
+++ b/src/sna/sna_render.h
@@ -148,6 +148,10 @@ struct sna_composite_op {
 		struct {
 			uint32_t flags;
 		} gen8;
+
+		struct {
+			uint32_t flags;
+		} gen9;
 	} u;
 
 	void *priv;
@@ -570,6 +574,57 @@ struct gen8_render_state {
 	bool emit_flush;
 };
 
+enum {
+	GEN9_WM_KERNEL_NOMASK = 0,
+	GEN9_WM_KERNEL_NOMASK_P,
+
+	GEN9_WM_KERNEL_MASK,
+	GEN9_WM_KERNEL_MASK_P,
+
+	GEN9_WM_KERNEL_MASKCA,
+	GEN9_WM_KERNEL_MASKCA_P,
+
+	GEN9_WM_KERNEL_MASKSA,
+	GEN9_WM_KERNEL_MASKSA_P,
+
+	GEN9_WM_KERNEL_OPACITY,
+	GEN9_WM_KERNEL_OPACITY_P,
+
+	GEN9_WM_KERNEL_VIDEO_PLANAR,
+	GEN9_WM_KERNEL_VIDEO_PACKED,
+	GEN9_WM_KERNEL_VIDEO_RGB,
+	GEN9_WM_KERNEL_COUNT
+};
+
+struct gen9_render_state {
+	unsigned gt;
+	const struct gt_info *info;
+	struct kgem_bo *general_bo;
+
+	uint32_t vs_state;
+	uint32_t sf_state;
+	uint32_t sf_mask_state;
+	uint32_t wm_state;
+	uint32_t wm_kernel[GEN9_WM_KERNEL_COUNT][3];
+
+	uint32_t cc_blend;
+
+	uint32_t drawrect_offset;
+	uint32_t drawrect_limit;
+	uint32_t blend;
+	uint32_t samplers;
+	uint32_t kernel;
+
+	uint16_t num_sf_outputs;
+	uint16_t ve_id;
+	uint16_t last_primitive;
+	int16_t floats_per_vertex;
+	uint16_t surface_table;
+
+	bool needs_invariant;
+	bool emit_flush;
+};
+
 struct sna_static_stream {
 	uint32_t size, used;
 	uint8_t *data;
@@ -625,6 +680,7 @@ const char *gen5_render_init(struct sna *sna, const char *backend);
 const char *gen6_render_init(struct sna *sna, const char *backend);
 const char *gen7_render_init(struct sna *sna, const char *backend);
 const char *gen8_render_init(struct sna *sna, const char *backend);
+const char *gen9_render_init(struct sna *sna, const char *backend);
 
 void sna_render_mark_wedged(struct sna *sna);
 
